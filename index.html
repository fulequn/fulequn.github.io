<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta property="og:type" content="website"><meta property="og:title" content="FuLeQun&#39;s Blog"><meta property="og:url" content="https://fulequn.github.io/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><title>FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:100vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="一生努力，一生被爱，想要的都拥有，得不到的都释怀"></span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container nopadding-x-md"><div id="board" style="margin-top:0"><div class="container"><div class="row"><div class="col-12 col-md-10 m-auto"><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405181/" target="_self">算法训练3.2.1 基础DP</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405181/" target="_self"><div>斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 示例 1： 输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) =</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-18 21:30" pubdate>2024-05-18</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405121/" target="_self">算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第二部分</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405121/" target="_self"><div>零钱兑换 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：c</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-12 21:25" pubdate>2024-05-12</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405111/" target="_self">使用 Java 实现快速排序（递归+非递归）</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405111/" target="_self"><div>快速排序 (Quick Sort) 快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。 快速排序的基本思想：通过一趟排序将待排序列分隔</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-11 21:45" pubdate>2024-05-11</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405102/" target="_self">算法训练-6高效算法部分 单调队列</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405102/" target="_self"><div>单调队列解决的问题非常单一，用于优化：“区间最值问题”。模板如下： 123456queue;//单调队列for (int i = 0 ; i &lt; n ; i++) &#123; if (窗口达到上限) q.popleft(); while (queue &amp;&amp; nums[q.back()] &gt;= nums[i]) queue.pop(); queue.p</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-10 23:39" pubdate>2024-05-10</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405101/" target="_self">算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405101/" target="_self"><div>前言 记忆化搜索其实就是在递归的基础上记录已经算过的状态，下次如果运算过相同的状态后，直接返回已经算过的状态，避免重复运算。 这种算法在笔试过程中是非常好用的一个算法，能够解决非常多的问题，特别是一些比较复杂的动态规划，用记忆化搜索可以很快且很形象的解决问题。 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-10 23:03" pubdate>2024-05-10</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405081/" target="_self">超卖问题（图解 + 秒懂 + 史上最全）</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405081/" target="_self"><div>前言 先来就库存超卖的问题作描述：一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是众多电子商务网站程序员头疼的问题，这同时也是最基本的问题。 在秒杀系统设计中，超卖是一个经典、常见的问题，任何商品都会有数量上限，如何避免成功下订单</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-08 21:05" pubdate>2024-05-08</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405072/" target="_self">超卖问题-多位骑手抢一个外卖订单，如何保证只有一个骑手可以接到单子？</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405072/" target="_self"><div>类似的问题： 多位用户抢一个商品，如何保证只有一个用户可以抢到商品？ 多位用户抢一个红包，如何保证只有一个抢到？ 在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。 举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-07 22:50" pubdate>2024-05-07</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405071/" target="_self">算法训练-6高效算法部分 单调栈</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405071/" target="_self"><div>6.4 单调栈 单调栈是一种基于栈的数据结构，所谓的单调就是满足单调递增（单调递减）的栈。主要用于解决 next_greater 问题，也就是找到下一个更大的元素。 基本模板如下： 12345678stack;//单调栈for (int i = 0 ; i &lt; n ; i++) &#123; while (stack &amp;&amp; nums[stack.top] &lt;</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-07 22:49" pubdate>2024-05-07</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405061/" target="_self">算法训练-6高效算法部分 贪心算法</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405061/" target="_self"><div>6.3 贪心算法 前言 贪心算法一般出现在笔试题中，面试出现的概率非常低。贪心算法理解并不难，他区分于我们常用DFS/BFS/DP，他并不会枚举所有情况，而是只选择其中“当前最优”的情况。因此，贪心算法的思想并不难，甚至代码也并不难实现，但是难点在于找到贪心的策略和证明贪心策略有可行性。 贪心的正确性严格意义上来说是需要数学证明的，但这超出了数据结构的范畴，特别是笔试的时候，几乎不会有充足的时</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-06 16:06" pubdate>2024-05-06</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405051/" target="_self">算法训练-6高效算法部分 二分查找</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405051/" target="_self"><div>6.2 二分查找 前言 二分查找的思想非常简单，在有序的数据中每次按照中点进行尝试，如果中间点大于我们要查找的值，则答案应该位于左侧， 反之右侧。由于每次可以排除现有数据量的一半，因此时间复杂度是O(logn)O(logn)O(logn)。 以下我们提供两套二分查找的模板。两个模板的原理都是一样的，区别在于边界的处理。二分查找的难点往往也在于边界。因此如果我们划分的边界是[l,mid]和[mi</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-05 10:38" pubdate>2024-05-05</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405041/" target="_self">算法训练-6高效算法部分 滑动窗口</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405041/" target="_self"><div>前言 滑动窗口主要解决“满足某个条件的连续子串”问题，因为我们枚举 区间、子数组、子串 问题的时候时间复杂度是O(n2)O(n^2)O(n2)，使用滑窗可以将时间复杂度优化至O(n)O(n)O(n)。 代码模板如下： 1234for (int l = 0, r = 0 ; r &lt; n ; r++) &#123; // 如果右指针的元素加入到窗口内后，根据题目判断进行滑动左指针</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-04 20:45" pubdate>2024-05-04</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405031/" target="_self">详细了解 RBAC（Role-Based Access Control）</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405031/" target="_self"><div>摘要：本文介绍了基于角色的访问控制（RBAC），包括什么是 RBAC？什么是 RBAC 中的角色？什么是 RBAC 中的权限？NIST 标准包含的 4 级 RBAC 模型，使用 RBAC 的好处，使用 RBAC 的缺陷，RBAC 的实践，RBAC vs. ABAC vs. ACL vs. PBAC，RBAC &amp; IAM。 什么是 RBAC？ RBAC 允许您通过分配一组权限来创建和实施高</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-03 18:49" pubdate>2024-05-03</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405021/" target="_self">常见的查找算法与排序算法</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405021/" target="_self"><div>1 常见的七种查找算法 1.1 基本查找 也叫做顺序查找。说明：顺序查找适合于存储结构为数组或者链表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。 示例代码： 123456789101112131415161718192021222324252627</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-02 22:31" pubdate>2024-05-02</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/05/Article202405011/" target="_self">2024.5.1 计算机基础（快速排序）+算法（最小生成树）</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/05/Article202405011/" target="_self"><div>计算机基础 题目 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一 “趟”。下列排序中，不可能是快速排序第二趟结果的是（）【2019 年全国试题 10（2 分）】 A. 5, 2, 16, 12, 28, 60, 32, 72 B. 2, 16, 5, 28, 12, 60, 32, 72 C. 2, 12, 16, 5, 28, 32, 72, 60 D. 5, 2, 12, 28</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-05-01 20:45" pubdate>2024-05-01</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/04/Article202404301/" target="_self">如何实现第三方授权登录？</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/04/Article202404301/" target="_self"><div>面试中，第三方授权登录是场景题常考的一个知识点。 第三方授权登录具体的问法，常见的如下面这些形式： 如何实现第三方授权登录？ 如果我们的网站要对接第三方登录，你该怎么做？ 如何快速接入一个新开发的网站，让公司内部的员工可以访问？ 如何让别人的应用支持使用我们的产品进行第三方登录？ …… 考虑到很多同学还不清楚第三方授权登录的基本知识，因此，这篇文章会从基础开始讲起，最后我会给出一个面试回答的简</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-04-30 18:02" pubdate>2024-04-30</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/04/Article202404291/" target="_self">2024.4.29 计算机基础+算法</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/04/Article202404291/" target="_self"><div>计算机基础 B站笔试 涉及的知识点总结 在 jstat 命令的使用中，有一些特定的选项用于输出 Java 虚拟机的统计信息。以下是对每个选项的解释： jstat -gc：这个命令用于输出垃圾收集统计信息，包括堆中各区域的使用情况和垃圾收集次数等。 jstat -gccause：这个命令用于输出垃圾收集统计信息以及最后一次垃圾收集的原因。 jstat -gcnew：这个命令用于输出新生代的垃圾</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-04-29 12:47" pubdate>2024-04-29</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/04/Article202404281/" target="_self">2024.4.28 美团笔试复盘</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/04/Article202404281/" target="_self"><div>算法 美团0427笔试 美团笔试，上强度了！（0427春招实习笔试真题解析） 1 小美换团 小美拿到了一个字符串，她准备把其中所有的&quot;mei&quot;子串替换为&quot;tuan&quot;子串，你能帮帮她吗？ 输入描述 一个仅由小写字母组成的字符串。长度不超100000 输出描述 修改后的字符串。 示例 1 输入 meituan 输出 tuantuan 思路与代码 打卡题。直</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-04-28 12:47" pubdate>2024-04-28</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/03/Article202403201/" target="_self">Windows环境下Mysql安装与密码设置</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/03/Article202403201/" target="_self"><div>1 MySQL 安装 所有平台的 MySQL 下载地址为： MySQL 下载 。 挑选你需要的 MySQL Community Server 版本及对应的平台。 **注意：**安装过程我们需要通过开启管理员权限来安装，否则会由于权限不足导致无法安装。 进入官网找到自己所需的安装包：https://dev.mysql.com/ ，路径：DOWNLOAD–&gt;MYSQL Community</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-03-20 15:33" pubdate>2024-03-20</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/02/Article202402291/" target="_self">实习攻略：从简历到面试一网打尽</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/02/Article202402291/" target="_self"><div>实习对于求职者而言，是踏入职场的第一步，也是获取宝贵经验的良机。但如何才能在激烈的竞争中脱颖而出呢？本文将从简历制作到面试技巧，为你解答一切关于实习的疑问。 制作简历 下面是简历应该包含的内容：个人信息（基本信息，教育背景，照片）、履历信息（实习经历、项目经历、科研经历）、补充信息（如下图）。 此外，还有一些需要注意的点： 1.简历中的内容要简要精练，突出含金量高的部分； 2.在写自己的履</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-02-29 22:05" pubdate>2024-02-29</time></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h2 class="index-header"><a href="/2024/02/Article202402251/" target="_self">2024.2.25 LeetCode刷题+Java基础（String类）</a></h2><a class="index-excerpt index-excerpt__noimg" href="/2024/02/Article202402251/" target="_self"><div>Leetcode刷题 2. 两数相加 - 力扣（LeetCode） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; *</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2024-02-25 22:29" pubdate>2024-02-25</time></div></div></article></div><nav aria-label="navigation"><span class="pagination" id="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#board">2</a><a class="page-number" href="/page/3/#board">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/#board">14</a><a class="extend next" rel="next" href="/page/2/#board"><i class="iconfont icon-arrowright"></i></a></span></nav></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>