<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="参考链接： https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;tree&#x2F;master&#x2F;pkg&#x2F;scheduler&#x2F;framework&#x2F;plugins  Scheduler Framework Plugins（调度程序框架插件）  Creating a new in-tree plugin（创建一个新的树内插件） Read the docs to understand"><meta property="og:type" content="article"><meta property="og:title" content="Kubernetes调度器插件"><meta property="og:url" content="https://fulequn.github.io/2020/11/Article202011213/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="参考链接： https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;tree&#x2F;master&#x2F;pkg&#x2F;scheduler&#x2F;framework&#x2F;plugins  Scheduler Framework Plugins（调度程序框架插件）  Creating a new in-tree plugin（创建一个新的树内插件） Read the docs to understand"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241929863.png"><meta property="article:published_time" content="2020-11-21T10:20:32.000Z"><meta property="article:modified_time" content="2024-05-30T00:16:32.000Z"><meta property="article:author" content="Fulequn"><meta property="article:tag" content="Kubernetes"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241929863.png"><title>Kubernetes调度器插件 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Kubernetes调度器插件"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-11-21 18:20" pubdate>2020年11月21日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>3.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>28 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Kubernetes调度器插件</h1><div class="markdown-body"><p>参考链接：</p><p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler/framework/plugins">https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler/framework/plugins</a></p><h1 id="scheduler-framework-plugins调度程序框架插件"><a class="markdownIt-Anchor" href="#scheduler-framework-plugins调度程序框架插件"></a> Scheduler Framework Plugins（调度程序框架插件）</h1><h2 id="creating-a-new-in-tree-plugin创建一个新的树内插件"><a class="markdownIt-Anchor" href="#creating-a-new-in-tree-plugin创建一个新的树内插件"></a> Creating a new in-tree plugin（创建一个新的树内插件）</h2><p>Read <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/">the docs</a> to understand the different extension points within the scheduling framework.</p><p>TODO(<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/95156">#95156</a>): flesh this out a bit more.</p><p>阅读文档以了解调度框架内的不同扩展点。</p><p>TODO（＃95156）：将其充实一些。</p><h2 id="adding-plugin-configuration-parameters-through-kubeschedulerconfiguration通过kubeschedulerconfiguration添加插件配置参数"><a class="markdownIt-Anchor" href="#adding-plugin-configuration-parameters-through-kubeschedulerconfiguration通过kubeschedulerconfiguration添加插件配置参数"></a> Adding plugin configuration parameters through <code>KubeSchedulerConfiguration</code>（通过KubeSchedulerConfiguration添加插件配置参数）</h2><p>You can give users the ability to configure parameters in scheduler plugins using <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/scheduling/config/"><code>KubeSchedulerConfiguration</code></a>. This section covers how you can add arguments to existing in-tree plugins <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/94814">(example PR)</a>. Let’s assume the plugin is called <code>FooPlugin</code> and we want to add an optional integer parameter named <code>barParam</code>.</p><p>您可以使用户能够使用KubeSchedulerConfiguration在调度程序插件中配置参数。 本节介绍如何向现有的树内插件（例如PR）添加参数。 假设该插件名为FooPlugin，我们想添加一个名为barParam的可选整数参数。</p><h3 id="defining-and-registering-the-struct定义和注册结构"><a class="markdownIt-Anchor" href="#defining-and-registering-the-struct定义和注册结构"></a> Defining and registering the struct（定义和注册结构）</h3><p>First, we need to define a struct type named <code>FooPluginArgs</code> in <code>pkg/scheduler/apis/config/types_pluginargs.go</code>, which is the representation of the configuration parameters that is internal to the scheduler.</p><p>首先，我们需要在pkg / scheduler / apis / config / types_pluginargs.go中定义一个名为FooPluginArgs的结构类型，该结构类型表示调度程序内部的配置参数。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> +k8s:deepcopy-gen:interfaces=k8s.io<span class="hljs-regexp">/apimachinery/</span>pkg/runtime.Object<br><br>type FooPluginArgs struct &#123;<br>	<span class="hljs-regexp">//</span> metav1 is k8s.io<span class="hljs-regexp">/apimachinery/</span>pkg<span class="hljs-regexp">/apis/m</span>eta/v1<br>	metav1.TypeMeta<br>	BarParam int32<br>&#125;<br></code></pre></td></tr></table></figure><p>Note that we embed <code>k8s.io/apimachinery/pkg/apis/meta/v1.TypeMeta</code> to include API metadata for <a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#api-conventions">versioning and persistence</a>. We add the <code>+k8s:deepcopy-gen:interfaces</code> comment to <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/code-generator">auto-generate a <code>DeepCopy</code> function</a> for the struct.</p><p>Similarly, define <code>FooPluginArgs</code> in <code>k8s.io/kube-scheduler/config/&#123;version&#125;/types_pluginargs.go</code>, which is the versioned representation used in the <code>kube-scheduler</code> binary used for deserialization. This time, however, in order to allow implicit default values for arguments, the type of the struct’s fields may be pointers; leaving a parameter unspecified will set the pointer field to its zero value (nil), which can be used to let the framework know that it must fill in the default value. <code>BarParam</code> is of type <code>int32</code> and let’s say we want a non-zero default value for it:</p><p>请注意，<a target="_blank" rel="noopener" href="http://xn--k8s-0h9d7rw2jnp1abxi.io/apimachinery/pkg/apis/meta/v1.TypeMeta%EF%BC%8C%E4%BB%A5%E5%8C%85%E5%90%AB%E7%94%A8%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84API%E5%85%83%E6%95%B0%E6%8D%AE%E3%80%82">我们嵌入了k8s.io/apimachinery/pkg/apis/meta/v1.TypeMeta，以包含用于版本控制和持久性的API元数据。</a> 我们添加+ k8s：deepcopy-gen：interfaces注释以自动生成该结构的DeepCopy函数。</p><p>同样，<a target="_blank" rel="noopener" href="http://xn--k8s-lp6e.io/kube-scheduler/config/%7Bversion%7D/types_pluginargs.go%E4%B8%AD%E5%AE%9A%E4%B9%89FooPluginArgs%EF%BC%8C%E8%BF%99%E6%98%AF%E7%94%A8%E4%BA%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84kube-scheduler%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E3%80%82">在k8s.io/kube-scheduler/config/{version}/types_pluginargs.go中定义FooPluginArgs，这是用于反序列化的kube-scheduler二进制文件中使用的版本表示形式。</a> 但是，这一次，为了允许参数使用隐式默认值，结构字段的类型可以是指针。 保留未指定的参数会将指针字段设置为其零值（nil），可用于使框架知道它必须填写默认值。 BarParam的类型为int32，假设我们想要一个非零的默认值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><br><span class="hljs-keyword">type</span> FooPluginArgs <span class="hljs-keyword">struct</span> &#123;<br>	metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>	BarParam *<span class="hljs-type">int32</span> <span class="hljs-string">`json:&quot;barParam,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>For each <code>types_pluginargs.go</code> addition, remember to register the type in the corresponding <code>register.go</code>, which will allow the scheduler to recognize <code>KubeSchedulerConfiguration</code> values at parse-time.</p><p>对于每个types_pluginargs.go，请记住在相应的register.go中注册类型，这将使调度程序在解析时识别KubeSchedulerConfiguration值。</p><h3 id="setting-defaults设置默认值"><a class="markdownIt-Anchor" href="#setting-defaults设置默认值"></a> Setting defaults（设置默认值）</h3><p>When a <code>KubeSchedulerConfiguration</code> object is parsed (happens in <code>cmd/kube-scheduler/app/options/options.go</code>), the scheduler will convert from the versioned type to the internal type, filling in the unspecified fields with defaults. Speaking of defaults, define <code>SetDefaults_FooPluginArgs</code> in <code>pkg/scheduler/apis/config/v1beta1/defaults.go</code> as follows:</p><p>解析KubeSchedulerConfiguration对象时（发生在cmd / kube-scheduler / app / options / options.go中），调度程序将从版本化类型转换为内部类型，并使用默认值填充未指定的字段。 说到默认值，请在pkg / scheduler / apis / config / v1beta1 / defaults.go中定义SetDefaults_FooPluginArgs，如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// v1beta1 refers to k8s.io/kube-scheduler/config/v1beta1.</span><br>func <span class="hljs-built_in">SetDefaults_FooPluginArgs</span>(obj *v1beta1.FooPluginArgs) &#123;<br>	<span class="hljs-keyword">if</span> obj<span class="hljs-selector-class">.BarParam</span> == nil &#123;<br>		obj<span class="hljs-selector-class">.BarParam</span> = pointer<span class="hljs-selector-class">.Int32Ptr</span>(<span class="hljs-number">42</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="validating-configuration-at-runtime在运行时验证配置"><a class="markdownIt-Anchor" href="#validating-configuration-at-runtime在运行时验证配置"></a> Validating configuration at runtime（在运行时验证配置）</h3><p>Next, we need to define validators to make sure the user’s configuration and your default values are valid. To do this, add something like this in <code>pkg/scheduler/apis/config/validation/validation_pluginargs.go</code>:</p><p>接下来，我们需要定义验证器以确保用户的配置和您的默认值有效。 为此，请在pkg / scheduler / apis / config / validation / validation_pluginargs.go中添加以下内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// From here on, FooPluginArgs refers to the type defined in pkg/scheduler</span><br><span class="hljs-comment">// definition, not the kube-scheduler definition. We&#x27;re dealing with</span><br><span class="hljs-comment">// post-default values.</span><br>func ValidateFooPluginArgs(<span class="hljs-keyword">args</span> config.FooPluginArgs) <span class="hljs-keyword">error</span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-keyword">args</span>.BarParam &lt; 0 &amp;&amp; <span class="hljs-keyword">args</span>.BarParam &gt; 100 &#123;<br>		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;must be in the range [0, 100]&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="code-generation代码生成"><a class="markdownIt-Anchor" href="#code-generation代码生成"></a> Code generation（代码生成）</h3><p>We have defined everything necessary to run code generation now. Remember to commit all your changes (not sure why this is needed) and do a <code>make clean</code> first. Then:</p><p>我们已经定义了现在运行代码生成所需的一切。 记住要提交所有更改（不确定为什么需要这样做），并先进行清理。 然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/k8s.io/kubernetes</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -A &amp;&amp; git commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./hack/update-codegen.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make generated_files</span><br></code></pre></td></tr></table></figure><p>This should automatically generate code to deep copy objects, convert between different struct types, convert pointer types to raw types, and set defaults.</p><p>这将自动生成代码以深层复制对象，在不同的结构类型之间转换，将指针类型转换为原始类型，并设置默认值。</p><h3 id="testing测试"><a class="markdownIt-Anchor" href="#testing测试"></a> Testing（测试）</h3><p>After code generation, go back and write tests for all of the changes you made in the previous section:</p><p>生成代码后，返回并为您在上一节中所做的所有更改编写测试：</p><ul><li><code>pkg/scheduler/apis/config/v1beta1/defaults_test.go</code> to unit test the defaults. pkg / scheduler / apis / config / v1beta1 / defaults_test.go对默认值进行单元测试。</li><li><code>pkg/scheduler/apis/config/validation/validation_pluginargs_test.go</code> to unit test the validator. pkg / scheduler / apis / config / validation / validation_pluginargs_test.go对验证器进行单元测试。</li><li><code>pkg/scheduler/apis/config/scheme/scheme_test.go</code> to test the whole pipeline using a <code>KubeSchedulerConfiguration</code> definition. pkg / scheduler / apis / config / scheme / scheme_test.go使用KubeSchedulerConfiguration定义来测试整个管道。</li></ul><h3 id="receiving-the-arguments-in-the-plugin接收插件中的参数"><a class="markdownIt-Anchor" href="#receiving-the-arguments-in-the-plugin接收插件中的参数"></a> Receiving the arguments in the plugin（接收插件中的参数）</h3><p>We can now finally receive <code>FooPluginArgs</code> in the plugin code. To do this, modify the plugin’s <code>New</code> method signature like so:</p><p>现在，我们终于可以在插件代码中接收FooPluginArgs了。 为此，请修改插件的New方法签名，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(fpArgs runtime.Object, fh framework.FrameworkHandle)</span></span> (framework.Plugin, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-comment">// config.FooPluginArgs refers to the pkg/scheduler struct type definition.</span><br>	args, ok := fpArgs.(*config.FooPluginArgs)<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;got args of type %T, want *FooPluginArgs&quot;</span>, fpArgs)<br>	&#125;<br>	<span class="hljs-keyword">if</span> err := validation.ValidateFooPluginArgs(*args); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-comment">// Use args.BarParam as you like.</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="scheduling-framework调度框架"><a class="markdownIt-Anchor" href="#scheduling-framework调度框架"></a> Scheduling Framework（调度框架）</h1><p><strong>FEATURE STATE:</strong> <code>Kubernetes v1.15 [alpha]</code></p><p>The scheduling framework is a pluggable architecture for Kubernetes Scheduler that makes scheduler customizations easy. It adds a new set of “plugin” APIs to the existing scheduler. Plugins are compiled into the scheduler. The APIs allow most scheduling features to be implemented as plugins, while keeping the scheduling “core” simple and maintainable. Refer to the <a target="_blank" rel="noopener" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/README.md">design proposal of the scheduling framework</a> for more technical information on the design of the framework.</p><p>调度框架是Kubernetes Scheduler的可插入架构，可简化调度程序的自定义。 它将一组新的“插件” API添加到现有的调度程序中。 插件被编译到调度程序中。 这些API允许大多数调度功能实现为插件，同时使调度“核心”保持简单且可维护。 有关该框架设计的更多技术信息，请参阅调度框架的设计建议。</p><h1 id="framework-workflow框架工作流程"><a class="markdownIt-Anchor" href="#framework-workflow框架工作流程"></a> Framework workflow（框架工作流程）</h1><p>The Scheduling Framework defines a few extension points. Scheduler plugins register to be invoked at one or more extension points. Some of these plugins can change the scheduling decisions and some are informational only.</p><p>Each attempt to schedule one Pod is split into two phases, the <strong>scheduling cycle</strong> and the <strong>binding cycle</strong>.</p><p>计划框架定义了一些扩展点。 Scheduler插件注册以在一个或多个扩展点处调用。 这些插件中的一些可以更改计划决策，而某些仅提供信息。</p><p>每次调度一个Pod的尝试都分为两个阶段，即调度周期和绑定周期。</p><h2 id="scheduling-cycle-binding-cycle调度周期和绑定周期"><a class="markdownIt-Anchor" href="#scheduling-cycle-binding-cycle调度周期和绑定周期"></a> Scheduling Cycle &amp; Binding Cycle（调度周期和绑定周期）</h2><p>The scheduling cycle selects a node for the Pod, and the binding cycle applies that decision to the cluster. Together, a scheduling cycle and binding cycle are referred to as a “scheduling context”.</p><p>Scheduling cycles are run serially, while binding cycles may run concurrently.</p><p>A scheduling or binding cycle can be aborted if the Pod is determined to be unschedulable or if there is an internal error. The Pod will be returned to the queue and retried.</p><p>调度周期为Pod选择一个节点，并且绑定周期将该决定应用于集群。 调度周期和绑定周期一起被称为“调度上下文”。</p><p>调度周期是串行运行的，而绑定周期可能是同时运行的。</p><p>如果确定Pod不可调度或存在内部错误，则可以中止调度或绑定周期。 Pod将返回队列并重试。</p><h2 id="extension-points扩展点"><a class="markdownIt-Anchor" href="#extension-points扩展点"></a> Extension points（扩展点）</h2><p>The following picture shows the scheduling context of a Pod and the extension points that the scheduling framework exposes. In this picture “Filter” is equivalent to “Predicate” and “Scoring” is equivalent to “Priority function”.</p><p>One plugin may register at multiple extension points to perform more complex or stateful tasks.</p><p>下图显示了Pod的调度上下文以及调度框架公开的扩展点。 在此图片中，“过滤器”等效于“谓词”，“评分”等效于“优先级功能”。</p><p>一个插件可以在多个扩展点注册以执行更复杂或有状态的任务。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241929863.png" srcset="/img/loading.gif" lazyload alt="1"></p><p>scheduling framework extension points</p><p>调度框架扩展点</p><h3 id="queuesort队列排序"><a class="markdownIt-Anchor" href="#queuesort队列排序"></a> QueueSort（队列排序）</h3><p>These plugins are used to sort Pods in the scheduling queue. A queue sort plugin essentially provides a function. Only one queue sort plugin may be enabled at a time.<code>Less(Pod1, Pod2)</code></p><p>扩展用于对 Pod 的待调度队列进行排序，以决定先调度哪个 Pod，<code>QueueSort</code> 扩展本质上只需要实现一个方法 <code>Less(Pod1, Pod2)</code> 用于比较两个 Pod 谁更优先获得调度即可，同一时间点只能有一个 <code>QueueSort</code> 插件生效。</p><h3 id="prefilter"><a class="markdownIt-Anchor" href="#prefilter"></a> PreFilter</h3><p>These plugins are used to pre-process info about the Pod, or to check certain conditions that the cluster or the Pod must meet. If a PreFilter plugin returns an error, the scheduling cycle is aborted.</p><p>扩展用于对 Pod 的信息进行预处理，或者检查一些集群或 Pod 必须满足的前提条件，如果 <code>pre-filter</code> 返回了 error，则调度过程终止。</p><h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> Filter</h3><p>These plugins are used to filter out nodes that cannot run the Pod. For each node, the scheduler will call filter plugins in their configured order. If any filter plugin marks the node as infeasible, the remaining plugins will not be called for that node. Nodes may be evaluated concurrently.</p><p>扩展用于排除那些不能运行该 Pod 的节点，对于每一个节点，调度器将按顺序执行 <code>filter</code> 扩展；如果任何一个 <code>filter</code> 将节点标记为不可选，则余下的 <code>filter</code> 扩展将不会被执行。调度器可以同时对多个节点执行 <code>filter</code> 扩展。</p><h3 id="postfilter"><a class="markdownIt-Anchor" href="#postfilter"></a> PostFilter</h3><p>These plugins are called after Filter phase, but only when no feasible nodes were found for the pod. Plugins are called in their configured order. If any postFilter plugin marks the node as , the remaining plugins will not be called. A typical PostFilter implementation is preemption, which tries to make the pod schedulable by preempting other Pods.<code>Schedulable</code></p><p>是一个通知类型的扩展点，调用该扩展的参数是 <code>filter</code> 阶段结束后被筛选为<strong>可选节点</strong>的节点列表，可以在扩展中使用这些信息更新内部状态，或者产生日志或 metrics 信息。</p><h3 id="prescore"><a class="markdownIt-Anchor" href="#prescore"></a> PreScore</h3><p>These plugins are used to perform “pre-scoring” work, which generates a sharable state for Score plugins to use. If a PreScore plugin returns an error, the scheduling cycle is aborted.</p><p>这些插件用于执行“预评分”工作，从而为Score插件使用提供可共享的状态。 如果PreScore插件返回错误，则调度周期将中止。</p><h3 id="score"><a class="markdownIt-Anchor" href="#score"></a> Score</h3><p>These plugins are used to rank nodes that have passed the filtering phase. The scheduler will call each scoring plugin for each node. There will be a well defined range of integers representing the minimum and maximum scores. After the <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#normalize-scoring">NormalizeScore</a> phase, the scheduler will combine node scores from all plugins according to the configured plugin weights.</p><p>扩展用于为所有可选节点进行打分，调度器将针对每一个节点调用 <code>Soring</code> 扩展，评分结果是一个范围内的整数。在 <code>normalize scoring</code> 阶段，调度器将会把每个 <code>scoring</code> 扩展对具体某个节点的评分结果和该扩展的权重合并起来，作为最终评分结果。</p><h3 id="normalizescore"><a class="markdownIt-Anchor" href="#normalizescore"></a> NormalizeScore</h3><p>These plugins are used to modify scores before the scheduler computes a final ranking of Nodes. A plugin that registers for this extension point will be called with the <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#scoring">Score</a> results from the same plugin. This is called once per plugin per scheduling cycle.</p><p>For example, suppose a plugin ranks Nodes based on how many blinking lights they have.<code>BlinkingLightScorer</code></p><p>这些插件用于在调度程序计算节点的最终排名之前修改分数。 注册此扩展点的插件将与同一插件的得分结果一起调用。 每个插件每个调度周期调用一次。</p><p>例如，假设一个插件根据节点有多少个闪烁的灯光对节点进行排名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ScoreNode</span><span class="hljs-params">(_ *v1.pod, n *v1.Node)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> getBlinkingLightCount(n)<br>&#125;<br></code></pre></td></tr></table></figure><p>However, the maximum count of blinking lights may be small compared to . To fix this, should also register for this extension point.<code>NodeScoreMax``BlinkingLightScorer</code></p><p>但是，与相比，闪烁灯的最大数量可能少。 要解决此问题，还应注册此扩展点。NodeScoreMaxBlinkingLightScorer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NormalizeScores</span><span class="hljs-params">(scores <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    highest := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, score := <span class="hljs-keyword">range</span> scores &#123;<br>        highest = max(highest, score)<br>    &#125;<br>    <span class="hljs-keyword">for</span> node, score := <span class="hljs-keyword">range</span> scores &#123;<br>        scores[node] = score*NodeScoreMax/highest<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If any NormalizeScore plugin returns an error, the scheduling cycle is aborted.</p><p>如果任何NormalizeScore插件返回错误，则调度周期将中止。</p><blockquote><p><strong>Note:</strong> Plugins wishing to perform “pre-reserve” work should use the NormalizeScore extension point.</p><p>希望执行“预保留”工作的插件应使用NormalizeScore扩展点。</p></blockquote><h3 id="reserve"><a class="markdownIt-Anchor" href="#reserve"></a> Reserve</h3><p>A plugin that implements the Reserve extension has two methods, namely and , that back two informational scheduling phases called Reserve and Unreserve, respectively. Plugins which maintain runtime state (aka “stateful plugins”) should use these phases to be notified by the scheduler when resources on a node are being reserved and unreserved for a given Pod.<code>Reserve``Unreserve</code></p><p>The Reserve phase happens before the scheduler actually binds a Pod to its designated node. It exists to prevent race conditions while the scheduler waits for the bind to succeed. The method of each Reserve plugin may succeed or fail; if one method call fails, subsequent plugins are not executed and the Reserve phase is considered to have failed. If the method of all plugins succeed, the Reserve phase is considered to be successful and the rest of the scheduling cycle and the binding cycle are executed.<code>Reserve``Reserve``Reserve</code></p><p>The Unreserve phase is triggered if the Reserve phase or a later phase fails. When this happens, the method of <strong>all</strong> Reserve plugins will be executed in the reverse order of method calls. This phase exists to clean up the state associated with the reserved Pod.<code>Unreserve``Reserve</code></p><p>实现Reserve扩展的插件有两个方法，即和和，分别支持两个信息调度阶段，分别称为Reserve和Unreserve。 维护运行时状态的插件（也称为“有状态插件”）应在给定Pod保留和不保留节点上的资源时使用这些阶段由调度程序通知。</p><p>保留阶段发生在调度程序实际将Pod绑定到其指定节点之前。 它的存在是为了防止调度程序在等待绑定成功时出现争用情况。 每个Reserve插件的方法可能成功或失败； 如果一个方法调用失败，则不执行后续插件，并且保留阶段被视为失败。 如果所有插件的方法都成功，则认为Reserve阶段成功，并且将执行其余的调度周期和绑定周期。</p><p>如果保留阶段或后续阶段失败，则会触发取消保留阶段。 发生这种情况时，所有Reserve插件的方法将以与方法调用相反的顺序执行。 存在此阶段以清理与保留Pod.UnreserveReserve关联的状态。</p><blockquote><p><strong>Caution:</strong> The implementation of the method in Reserve plugins must be idempotent and may not fail.<code>Unreserve</code></p><p>警告：Reserve插件中方法的实现必须是幂等的，并且不能失败。</p></blockquote><h3 id="permit"><a class="markdownIt-Anchor" href="#permit"></a> Permit</h3><p><em>Permit</em> plugins are invoked at the end of the scheduling cycle for each Pod, to prevent or delay the binding to the candidate node. A permit plugin can do one of the three things:</p><p>在每个Pod的调度周期结束时，将调用许可插件，以防止或延迟与候选节点的绑定。 一个许可插件可以做以下三件事之一：</p><ol><li><strong>approve</strong><br>Once all Permit plugins approve a Pod, it is sent for binding. 一旦所有许可插件批准Pod，便将其发送以进行绑定。</li><li><strong>deny</strong><br>If any Permit plugin denies a Pod, it is returned to the scheduling queue. This will trigger the Unreserve phase in <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#reserve">Reserve plugins</a>. 如果任何许可证插件拒绝Pod，则将其返回到调度队列。 这将触发Reserve插件中的Unreserve阶段。</li><li><strong>wait</strong> (with a timeout)<br>If a Permit plugin returns “wait”, then the Pod is kept in an internal “waiting” Pods list, and the binding cycle of this Pod starts but directly blocks until it gets approved. If a timeout occurs, <strong>wait</strong> becomes <strong>deny</strong> and the Pod is returned to the scheduling queue, triggering the Unreserve phase in <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#reserve">Reserve plugins</a>. 如果许可证插件返回“ wait”，则Pod会保留在内部的“ waiting” Pods列表中，此Pod的绑定周期开始，但会直接阻塞，直到获得批准为止。 如果发生超时，等待将变为拒绝，并且Pod将返回到调度队列，从而触发Reserve插件中的Unreserve阶段。</li></ol><blockquote><p><strong>Note:</strong> While any plugin can access the list of “waiting” Pods and approve them (see <a target="_blank" rel="noopener" href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#frameworkhandle"><code>FrameworkHandle</code></a>), we expect only the permit plugins to approve binding of reserved Pods that are in “waiting” state. Once a Pod is approved, it is sent to the <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#pre-bind">PreBind</a> phase.</p><p>注意：尽管任何插件都可以访问“正在等待”的Pod列表并进行批准（请参阅FrameworkHandle），但我们希望只有allow插件才能批准处于“等待”状态的保留Pod的绑定。 批准Pod后，将其发送到PreBind阶段。</p></blockquote><h3 id="prebind"><a class="markdownIt-Anchor" href="#prebind"></a> PreBind</h3><p>These plugins are used to perform any work required before a Pod is bound. For example, a pre-bind plugin may provision a network volume and mount it on the target node before allowing the Pod to run there.</p><p>If any PreBind plugin returns an error, the Pod is <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#reserve">rejected</a> and returned to the scheduling queue.</p><p>这些插件用于执行绑定Pod之前所需的任何工作。 例如，预绑定插件可以在允许Pod在此处运行之前预配置网络卷并将其安装在目标节点上。</p><p>如果任何PreBind插件返回错误，则Pod将被拒绝并返回到调度队列。</p><h3 id="bind"><a class="markdownIt-Anchor" href="#bind"></a> Bind</h3><p>These plugins are used to bind a Pod to a Node. Bind plugins will not be called until all PreBind plugins have completed. Each bind plugin is called in the configured order. A bind plugin may choose whether or not to handle the given Pod. If a bind plugin chooses to handle a Pod, <strong>the remaining bind plugins are skipped</strong>.</p><p>这些插件用于将Pod绑定到节点。 在所有PreBind插件完成之前，不会调用绑定插件。 每个绑定插件均按配置顺序调用。 绑定插件可以选择是否处理给定的Pod。 如果绑定插件选择处理Pod，则会跳过其余的绑定插件。</p><h3 id="postbind"><a class="markdownIt-Anchor" href="#postbind"></a> PostBind</h3><p>This is an informational extension point. Post-bind plugins are called after a Pod is successfully bound. This is the end of a binding cycle, and can be used to clean up associated resources.</p><p>这是一个信息扩展点。 成功绑定Pod后，将调用后绑定插件。 这是绑定周期的结束，可用于清理关联的资源。</p><h2 id="plugin-api"><a class="markdownIt-Anchor" href="#plugin-api"></a> Plugin API</h2><p>There are two steps to the plugin API. First, plugins must register and get configured, then they use the extension point interfaces. Extension point interfaces have the following form.</p><p>插件API有两个步骤。 首先，插件必须注册并配置，然后才能使用扩展点接口。 扩展点接口具有以下形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Plugin <span class="hljs-keyword">interface</span> &#123;<br>    Name() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> QueueSortPlugin <span class="hljs-keyword">interface</span> &#123;<br>    Plugin<br>    Less(*v1.pod, *v1.pod) <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PreFilterPlugin <span class="hljs-keyword">interface</span> &#123;<br>    Plugin<br>    PreFilter(context.Context, *framework.CycleState, *v1.pod) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h2 id="plugin-configuration插件配置"><a class="markdownIt-Anchor" href="#plugin-configuration插件配置"></a> Plugin configuration（插件配置）</h2><p>You can enable or disable plugins in the scheduler configuration. If you are using Kubernetes v1.18 or later, most scheduling <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/scheduling/config/#scheduling-plugins">plugins</a> are in use and enabled by default.</p><p>In addition to default plugins, you can also implement your own scheduling plugins and get them configured along with default plugins. You can visit <a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/scheduler-plugins">scheduler-plugins</a> for more details.</p><p>If you are using Kubernetes v1.18 or later, you can configure a set of plugins as a scheduler profile and then define multiple profiles to fit various kinds of workload. Learn more at <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/scheduling/config/#multiple-profiles">multiple profiles</a>.</p><p>您可以在调度程序配置中启用或禁用插件。 如果您使用的是Kubernetes v1.18或更高版本，则大多数调度插件都在使用中并默认启用。</p><p>除了默认插件外，您还可以实现自己的计划插件，并与默认插件一起配置它们。 您可以访问调度程序插件以获取更多详细信息。</p><p>如果您使用的是Kubernetes v1.18或更高版本，则可以将一组插件配置为调度程序配置文件，然后定义多个配置文件以适合各种工作负载。 了解更多有关多个配置文件的信息。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/" class="category-chain-item">技术工具</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Kubernetes/" class="print-no-link">#Kubernetes</a></div></div><div class="license-box my-3"><div class="license-title"><div>Kubernetes调度器插件</div><div>https://fulequn.github.io/2020/11/Article202011213/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2020年11月21日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2020/11/Article202011214/" title="更改Spyder的Python指定版本"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">更改Spyder的Python指定版本</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/11/Article202011212/" title="罗技K380连接windwos10电脑"><span class="hidden-mobile">罗技K380连接windwos10电脑</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>