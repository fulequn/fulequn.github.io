<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="参考链接： https:&#x2F;&#x2F;www.sohu.com&#x2F;a&#x2F;225585188_556060 http:&#x2F;&#x2F;www.360doc.com&#x2F;content&#x2F;16&#x2F;0330&#x2F;01&#x2F;31750011_546416731.shtml https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;34154663 https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1591109035165038"><meta property="og:type" content="article"><meta property="og:title" content="常用的分类算法"><meta property="og:url" content="https://fulequn.github.io/2020/10/Article202010081/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="参考链接： https:&#x2F;&#x2F;www.sohu.com&#x2F;a&#x2F;225585188_556060 http:&#x2F;&#x2F;www.360doc.com&#x2F;content&#x2F;16&#x2F;0330&#x2F;01&#x2F;31750011_546416731.shtml https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;34154663 https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1591109035165038"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241911919.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241911585.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912644.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912570.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912689.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912877.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912542.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912416.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910203.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912041.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910204.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910205.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910206.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910207.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912323.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910208.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910209.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910210.png"><meta property="og:image" content="https://fulequn.github.io/2020/10/Article202010081/19.jpeg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910211.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912529.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241913077.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910212.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910213.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910214.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910215.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910216.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910217.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910218.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910219.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910220.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910221.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910222.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910223.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910224.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910225.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910226.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241913519.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910227.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910228.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910229.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910230.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910231.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910232.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910233.png"><meta property="article:published_time" content="2020-10-08T15:33:31.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:07.510Z"><meta property="article:author" content="Fulequn"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241911919.jpg"><title>常用的分类算法 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="常用的分类算法"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-10-08 23:33" pubdate>2020年10月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>5.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>48 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">常用的分类算法</h1><div class="markdown-body"><blockquote><p>参考链接：</p><p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/225585188_556060">https://www.sohu.com/a/225585188_556060</a></p><p><a target="_blank" rel="noopener" href="http://www.360doc.com/content/16/0330/01/31750011_546416731.shtml">http://www.360doc.com/content/16/0330/01/31750011_546416731.shtml</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34154663">https://zhuanlan.zhihu.com/p/34154663</a></p><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1591109035165038806&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1591109035165038806&amp;wfr=spider&amp;for=pc</a></p></blockquote><p>机器学习本质上就是一种对问题真实模型的逼近。其中有监督的分类算法在众多的业务场景得到了非常广泛的应用，如：根据个人的学历、性别、年龄等信息判断用户是否会违约等。分类问题属于预测任务，就是通过已有数据集（训练集）的学习，得到一个<strong>目标函数f</strong>（模型），把每个属性集x映射到目标属性y（类），且y必须是离散的（若y为连续的，则属于回归算法）。</p><p>解决分类问题的方法很多 ， 基本的分类方法主要包括：决策树、朴素贝叶斯、人工神经网络、K-近邻、支持向量机等；另外还有用于组合基本分类器的集成学习算法，集成学习的代表算法有随机森林，adaboost，xgboost等。本篇文章主要总结了各基本分类器的基本原理和优缺点。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241911919.jpg" srcset="/img/loading.gif" lazyload alt="1"></p><p><strong>一、K近邻法(K-Nearest Neighbor，KNN)：</strong></p><p>KNN法即K近邻法，最初由Cover和Hart于1968年提出的，是一个理论上比较成熟的方法。人常说“物以类聚，人以群分”，要判断一个人的好坏就看看他周围的朋友，如果朋友都是好人，当然此君也极有可能是好人。反之亦然。KNN算法就是基于这种思想。</p><p>它的思路非常简单：找到训练集样本空间中的K个距离预测样本x最近的点，统计K个距离最近的点的类别，找出个数最多的类别，将x归入该类别。从下图的示例中可以清晰看出，当K=5时，未知样本xu应该属于类别w1。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241911585.jpg" srcset="/img/loading.gif" lazyload alt="2"></p><ol><li><strong>KNN法的三要素</strong></li></ol><p><strong>KNN法有三个基本要素：K值的选择、距离度量及分类决策规则。</strong></p><p><strong>（1）Ｋ值选择</strong></p><p>K太小，分类结果易受噪声点影响；K太大，近邻中又可能包含太多的其它类别的点。（对距离加权，可以降低k值设定的影响）。K值通常是采用交叉检验来确定。 经验规则：K一般低于训练样本数的平方根。</p><p><strong>（2）距离度量选择</strong></p><p>一般采用马氏距离或者欧式距离。需要注意的是，高维度和变量值域对距离衡量存在显著影响：当变量数越多，欧式距离的区分能力就越差；值域越大的变量常常会在距离计算中占据主导作用，因此应先对变量进行标准化。</p><p><strong>（3）决策规则</strong></p><p>投票法没有考虑近邻的距离的远近，距离更近的近邻也许对最终的分类有更大的影响，所以加权投票法更恰当一些。加权投票法中的权重随着样本间距离增大而减小。</p><ol start="2"><li><strong>KNN算法步骤</strong></li></ol><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912644.jpg" srcset="/img/loading.gif" lazyload alt="3"></p><p><strong>3. KNN算法的优缺点</strong></p><p><strong>优点：</strong></p><p>（1）简单有效，容易理解和实现。</p><p>（2）重新训练的代价较低（类别体系的变化和训练集的变化）。</p><p>（3）由于KNN方法主要依赖周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此<strong>对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。</strong></p><p>(4) 适合处理多模分类和多标签分类问题。</p><p><strong>缺点：</strong></p><p>（1）是lazy learning方法（决策在测试时生成），比一些积极学习的算法要慢；</p><p>（2）计算量比较大（需要计算到所有样本点的距离），需对样本点进行剪辑；</p><p>（3）样本不平衡会导致预测偏差较大，可采用加权投票法改进；</p><p>（4）容易对维度灾难敏感；</p><p>（5）类别评分不是规格化的（不像概率评分）。</p><p><strong>二、SVM法：</strong></p><p>SVM法即支持向量机(Support Vector Machine)法，是一个二分类的分类模型。由Vapnik等人于1995年提出。SVM的主要思想可以概括为两点（源自百度百科）：</p><p>（1）它是针对线性可分情况进行分析，对于线性不可分的情况，通过使用非线性映射算法将低维输入空间线性不可分的样本转化为高维特征空间使其线性可分，从而使得高维特征空间采用线性算法对样本的非线性特征进行线性分析成为可能。</p><p>（2）它基于结构风险最小化理论之上在特征空间中构建最优超平面，使得学习器得到<strong>全局最优解</strong>，并且在整个样本空间的期望以某个概率满足一定上界。</p><p><strong>1、线性可分</strong></p><p>支持向量机把分类问题转化为寻找分类平面的问题，并通过最大化分类边界点距离分类平面的距离来实现分类。故SVM法亦被称为最大边缘(maximum margin)算法。</p><p>举例说明SVM的思想</p><p><strong>源自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21094489">https://www.zhihu.com/question/21094489</a></strong></p><p>（1）对两类样本进行分类</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912570.jpg" srcset="/img/loading.gif" lazyload alt="4"></p><p>（2）想要找到可以将两类样本分隔开的直线（高维时则是找到超平面）</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912689.jpg" srcset="/img/loading.gif" lazyload alt="5"></p><p>（3）发现：增加样本数量后，很容易出现分类错误的样本</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912877.jpg" srcset="/img/loading.gif" lazyload alt="6"></p><p>（4）SVM就是试图找到最佳的直线，能让直线两边有尽可能大的间隙。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912542.jpg" srcset="/img/loading.gif" lazyload alt="7"></p><p>（5）这种情况下，即使增加了样本数量，仍然可以将不同类别的样本区分开。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912416.jpg" srcset="/img/loading.gif" lazyload alt="8"></p><p>将训练集中的数据区分开的超平面可以线性方程表示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910203.png" srcset="/img/loading.gif" lazyload alt="9"></p><p>假设两种样本的标签分别是{+1，-1}，那么对于一个分类器来说，f(x)&gt;0和个f(x)&lt;0就可以分别代表两个不同的类别，+1和-1。 但光是分开是不够的，SVM的核心思想是<strong>尽最大努力使分开的两个类别有最大间隔</strong>，这样才使得分隔具有更高的可信度。而且对于未知的新样本才有很好的分类预测能力（即泛化能力）。</p><p>为了描述这个间隔，并且让它最大，SVM的办法是：<strong>让离分隔面最近的数据点距离分隔面具有最大的距离。</strong></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912041.jpg" srcset="/img/loading.gif" lazyload alt="10"></p><p>将距离分离超平面最近的两个不同类别的样本点称为支持向量（support vector），两个类别中的支持向量构成了两条平行于分离超平面的长带，二者之间的距离称之为margin。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910204.png" srcset="/img/loading.gif" lazyload alt="11"></p><p>从上图中可观察到：margin以外的样本点对于确定分离超平面没有贡献，换句话说，SVM是由训练样本中很重要的支持向量所确定的。待分样本集中的大部分样本不是支持向量，移去或者减少这些样本对分类结果没有影响。因此，SVM具有较好的适应能力和较高的分准率。</p><p>SVM分类问题可描述为在全部分类正确的情况下，最大化间隔</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910205.png" srcset="/img/loading.gif" lazyload alt="12"></p><p>，等价于最小化</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910206.png" srcset="/img/loading.gif" lazyload alt="13"></p><p>。因此，SVM的约束最优化问题可以表示为：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910207.png" srcset="/img/loading.gif" lazyload alt="14"></p><p>2、线性不可分</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912323.jpg" srcset="/img/loading.gif" lazyload alt="15"></p><p>线性可分是理想情况，通常情况下，由于噪声或特异点等各种原因，训练样本是线性不可分的。线性不可分意味着公式（2.2）中的约束条件不再满足，为解决这个问题，可以对每个样本引入一个松弛变量</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910208.png" srcset="/img/loading.gif" lazyload alt="16"></p><p>。此时，约束最优化问题变为：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910209.png" srcset="/img/loading.gif" lazyload alt="17"></p><p>目标函数有两层含义：（1）margin尽量大，（2）误分类的样本点计量少。其中，C为惩罚函数，调节（1）和（2）的权重占比。</p><p>其等价的对偶优化问题：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910210.png" srcset="/img/loading.gif" lazyload alt="18"></p><p>3、非线性</p><p>对于非线性问题，线性SVM不再适用了，需要非线性SVM来解决了。解决非线性分类问题的思路，通过空间变换ϕ，<strong>一般是低维空间映射到高维空间x→ϕ(x)后实现线性可分</strong>，在下图所示的例子中，通过空间变换，将左图中的曲线分离变换成了右图中平面可分。</p><p><img src="/2020/10/Article202010081/19.jpeg" srcset="/img/loading.gif" lazyload alt="19"></p><p>在SVM的等价对偶问题中的目标函数中有样本点的内积xi⋅xj，在空间变换后则是ϕ(xi)⋅ϕ(xj)，由于维数增加导致内积计算成本增加，这时核函数（kernel function）便发挥作用了，<strong>将映射后的高维空间内积转换成低维空间的函数</strong>：K(x,z)=ϕ(x)⋅ϕ(z)，将其代入一般化的SVM学习算法的目标函数(2.4)中，可得非线性SVM的最优化问题：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910211.png" srcset="/img/loading.gif" lazyload alt="20"></p><p><strong>4、SVM的优缺点</strong></p><p><strong>优点：</strong></p><p>（1）<strong>适合小样本情况下的机器学习问题；</strong></p><p>（2）可以提高泛化性能；</p><p>（3）可以解决高维问题；</p><p>（4）可以解决非线性问题；</p><p>（5）可以避免神经网络结构选择和局部极小点问题。</p><p><strong>缺点：</strong></p><p>（1）对缺失数据敏感；</p><p>（2）对非线性问题没有通用解决方案，必须谨慎选择Kernel function来处理；</p><p>（3）计算复杂度高。主流的算法是O(n^2)的，大规模数据计算耗时。</p><p><strong>三、决策树分类算法</strong></p><p>决策树（decision tree）归纳是经典的分类算法。它采用自顶向下递归的方式构造决策树。可以从生成的决策树中提取规则。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241912529.jpg" srcset="/img/loading.gif" lazyload alt="21"></p><p>上图给出了（二叉）决策树的示例。决策树具有以下特点：</p><p>（1）对于二叉决策树而言，可以看作是if-then规则集合，由决策树的根节点到叶子节点对应于一条分类规则;</p><p>（2）分类规则是互斥并且完备的，所谓互斥即每一条样本记录不会同时匹配上两条分类规则，所谓完备即每条样本记录都在决策树中都能匹配上一条规则；</p><p>（3）分类的本质是对特征空间的划分，如下图所示。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241913077.jpg" srcset="/img/loading.gif" lazyload alt="22"></p><p>决策树思想，实际上就是<strong>寻找最纯净的划分方法</strong>，这个最纯净在数学上叫纯度，纯度通俗点理解就是目标变量要分得足够开（y=1的和y=0的混到一起就会不纯）。另一种理解是分类误差率的一种衡量。实际决策树算法往往用到的是纯度的另一面，即不纯度。不纯度的选取有多种方法，如信息熵，基尼指数，分类误差等。</p><p><strong>决策树要达到寻找最纯净划分的目标要干两件事，建树和剪枝。</strong></p><p><strong>1、决策树建树</strong></p><p>决策树建树，首先需要解决三个问题：</p><p><strong>（1） 如何选择较优的特征属性进行分裂？</strong></p><p>每一次特征属性的分裂，相当于对训练数据集进行再划分，对应于一次决策树的生长。选择较优的特征属性，首先需要对特征的重要性进行排序比较。也就是从树根节点到叶子节点上的特征变量是从最重要到次重要依次排序的，那怎么衡量这些变量的重要性呢？ID3算法用的是<strong>信息增益</strong>，C4.5算法用<strong>信息增益率</strong>；CART算法使用<strong>基尼系数</strong>。</p><p>为了判断分裂前后节点不纯度的变化情况，目标函数定义为信息增益（informationgain）：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910212.png" srcset="/img/loading.gif" lazyload alt="23"></p><p>I(⋅)对应于决策树节点的不纯度，parent表示分裂前的父节点，N表示父节点所包含的样本记录数，ai表示父节点分裂后的某子节点，N(ai)为其计数，n为分裂后的子节点数。特别地，ID3算法选取<strong>熵值</strong>作为不纯度I(⋅)的度量，则</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910213.png" srcset="/img/loading.gif" lazyload alt="24"></p><p>c指父节点对应所有样本记录的类别；A表示选择的特征属性，即ai的集合。那么，决策树学习中的信息增益Δ等价于训练数据集中类与特征的互信息，表示由于得知特征A的信息训练数据集c不确定性减少的程度。</p><p>在特征分裂后，有些子节点的记录数可能偏少，以至于影响分类结果。为了解决这个问题，CART算法提出了只进行特征的二元分裂，即决策树是一棵二叉树；C4.5算法改进分裂目标函数，用信息增益比（information gain ratio）来选择特征：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910214.png" srcset="/img/loading.gif" lazyload alt="25"></p><p>因而，特征选择的过程等同于计算每个特征的信息增益，选择最大信息增益的特征进行分裂。</p><p>决策树方法是会把每个特征都试一遍，然后选取那个，能够使分类分的最好的特征，也就是说将A属性作为父节点，产生的纯度增益（GainA）要大于B属性作为父节点产生的纯度增益（GainB），则A作为优先选取的属性。</p><p><strong>（2） 如何分裂训练数据（对每个属性选择最优的分割点）</strong></p><p>分裂准则依然是通过不纯度来分裂数据的，通过比较划分前后的不纯度值，来确定当前属性的最优分割点。</p><p><strong>（3） 什么时候应该停止分裂？</strong></p><p>有两种自然情况应该停止分裂：</p><p>- 该节点对应的所有样本记录均属于同一类别，</p><p>- 该节点对应的所有样本的特征属性值均相等。</p><p>但除此之外，还可以手动设定分裂停止条件：</p><p>- 树的深度达到设定的阈值，</p><p>- 该节点所含观测值的数量少于预设的父节点应含观测值数量的阈值，</p><p>- 该节点所含观测值的数量少于预设的阈值等。</p><p><strong>2、决策树剪枝</strong></p><p>生成的决策树对训练数据会有很好的分类效果，却可能对未知数据的预测不准确，即决策树模型发生过拟合（overfitting）——训练误差（training error）很小、泛化误差（generalization error，亦可看作为test error）较大。发生过拟合的根本原因是分类模型过于复杂，可能的原因如下：</p><p>(1) 训练数据集中有噪音样本点，对训练数据拟合的同时也对噪音进行拟合，从而影响了分类的效果；</p><p>(2) 决策树的叶子节点中缺乏有分类价值的样本记录，也就是说此叶子节点应被剪掉。</p><p>为了避免决策树过拟合，需要对树进行剪枝。《统计学习方法》（李航）中提出一种简单剪枝策略，通过极小化决策树的整体损失函数（loss function）或代价函数（cost function）来实现，决策树T的损失函数为：</p><p>Lα(T)=C(T)+α|T| (3.4)</p><p>其中，C(T)表示决策树的训练误差，α为调节参数，|T|为模型的复杂度。当模型越复杂时，训练的误差就越小。上述定义的损失正好做了两者之间的权衡。如果剪枝后损失函数减少了，即说明这是有效剪枝。具体剪枝算法可以由动态规划等来实现。</p><p>3、决策树的优缺点</p><p><strong>优点：</strong></p><p>(1) 计算复杂度不高，易于理解和解释；</p><p>(2) 数据预处理阶段比较简单，且可以处理缺失数据；</p><p>(3**) 能够同时处理数据型和分类型属性，**且可对有许多属性的数据集构造决策树，其他技术往往需要数据属性的单一；</p><p>(4) 是一个白盒模型，若给定一个观察模型，则根据所产生的决策树很容易推断出相应的逻辑表达式；</p><p>(5) 在相对短的时间内能够对大数据集合做出可行且效果良好的分类结果。</p><p><strong>缺点：</strong></p><p>（1）对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。因此建议用平衡的数据训练决策树；</p><p>（2）决策树的结果可能是不稳定的，因为在数据中一个很小的变化可能导致生成一个完全不同的树，这个问题可以通过使用集成决策树来解决；</p><p>（3）实际决策树学习算法是基于启发式算法，如贪婪算法，寻求在每个节点上的局部最优决策。这样的算法不能保证返回全局最优决策树；</p><p>（4）忽略属性之间的相关性；</p><p>（5）易于过拟合；</p><p>（6）对噪声数据较为敏感。</p><p><strong>四、朴素贝叶斯(Naïve Bayes)法</strong></p><p>**朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。**朴素贝叶斯分类器的主要思路：通过联合概率P(x,y)=P(x|y)P(y)建模，运用贝叶斯定理求解后验概率P(y|x)；将后验概率最大者对应的的类别作为预测类别，因为后验概率最大化，可以使得期望风险最小化（期望风险是全局的，是基于所有样本点的损失函数最小化的）。</p><p>朴素贝叶斯分类器</p><p>首先定义训练样本集，其类别</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910215.png" srcset="/img/loading.gif" lazyload alt="26"></p><p>，则训练样本中有N个样本，类别数为K，输入待测样本x，通过最大化后验概率的原则预测x类别的公式如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910216.png" srcset="/img/loading.gif" lazyload alt="27"></p><p>由<strong>贝叶斯定理</strong>可知：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910217.png" srcset="/img/loading.gif" lazyload alt="28"></p><p>对于类别ck而言，P(x)是恒等的，因此公式（4.1）可以等价为：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910218.png" srcset="/img/loading.gif" lazyload alt="29"></p><p>从上式可以发现，朴素贝叶斯分类问题转化成了求条件概率和先验概率乘积的最大值问题。其中先验概率可以通过统计不同类别样本出现频次得到，而条件概率却无法直接获得。朴素贝叶斯法对条件概率做了条件独立的假设，即特征条件独立。样本x有n维特征向量()，第j维特征x(j)的取值有Sj个。<strong>根据条件独立假设</strong>，可知</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910219.png" srcset="/img/loading.gif" lazyload alt="30"></p><p>因此，公式（4.2）等价于：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910220.png" srcset="/img/loading.gif" lazyload alt="31"></p><p>公式（4.3）即为贝叶斯分类器生成模型。</p><ol start="2"><li>朴素贝叶斯法的参数估计</li></ol><p>在朴素贝叶斯学习中，需要估计先验概率与条件概率。估计方法主要有极大似然估计和贝叶斯估计。</p><p>（1）极大似然估计</p><p>先验概率估计公式：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910221.png" srcset="/img/loading.gif" lazyload alt="32"></p><p>条件概率估计公式：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910222.png" srcset="/img/loading.gif" lazyload alt="33"></p><p>其中，第j维特征x(j)的取值有Sj个，取值集合为</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910223.png" srcset="/img/loading.gif" lazyload alt="34"></p><p>，每个特征向量共n个特征。</p><p>（2）贝叶斯估计</p><p>先验概率估计公式：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910224.png" srcset="/img/loading.gif" lazyload alt="35"></p><p>条件概率估计公式：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910225.png" srcset="/img/loading.gif" lazyload alt="36"></p><p>由上式可知：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910226.png" srcset="/img/loading.gif" lazyload alt="37"></p><p>贝叶斯估计的条件概率确为一种概率分布。且避免了所要估计的概率值为0的情况。λ=1时，这种方法被称为拉普拉斯平滑</p><ol start="3"><li>朴素贝叶斯分类器的优缺点</li></ol><p><strong>优点：</strong>（1）数学基础坚实，分类效率稳定，容易解释；（2）所需估计的参数很少，对缺失数据不太敏感；（3）无需复杂的迭代求解框架，<strong>适用于规模巨大的数据集。</strong></p><p>通常数据集会先执行属性选择过程，提高了属性之间的独立性，且朴素贝叶斯可以产生较为复杂的非线性决策面，可以拟合出相当复杂的曲面。</p><p><strong>缺点：</strong>（1）属性之间的独立性假设往往不成立（可考虑用聚类算法先将相关性较大的属性进行聚类）；（2）需要知道先验概率，分类决策存在错误率。</p><p><strong>五、神经网络</strong></p><p>神经网络由“神经元”构成，一个“神经元”是一个运算单元f，该运算单元在神经网络中称作激活函数，激活函数通常设定为sigmoid函数（也可以设为其他函数），它可以输入一组加权系数的量，对这个量进行映射，如果这个映射结果达到或者超过了某个阈值，输出一个量。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241913519.jpg" srcset="/img/loading.gif" lazyload alt="38"></p><p>有监督神经网络</p><p>在有监督任务中，**神经网络算法能够提供一种复杂且非线性的假设模型，**它具有网络参数W,b，可以以此参数来拟合数据。</p><p>如有输入值x1, x2, x3和它们的网络参数：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910227.png" srcset="/img/loading.gif" lazyload alt="39"></p><p>,输入值系数加权求和可以得到第二层网络中第一个“神经元”的输入，</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910228.png" srcset="/img/loading.gif" lazyload alt="40"></p><p>，该值经过“神经元”上的激活函数映射</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910229.png" srcset="/img/loading.gif" lazyload alt="41"></p><p>，得到“神经元”的激活值。一个“神经元”的输出可以作为下一层“神经元”的输入。对于第三层上的“神经元”，其输入是第二层“神经元”的输出</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910230.png" srcset="/img/loading.gif" lazyload alt="42"></p><p>与第二层的网络参数</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910231.png" srcset="/img/loading.gif" lazyload alt="43"></p><p>的加权求和，得到最终的网络输出</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910232.png" srcset="/img/loading.gif" lazyload alt="44"></p><p>。每个样本对应的分类误差为</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img231/202306241910233.png" srcset="/img/loading.gif" lazyload alt="45"></p><p>。神经网络分类算法的目标函数是最小化所有样本的分类误差。神经网络参数的确定需要用到反向传播算法（BP算法），这里不作具体介绍。</p><p>根据神将网络的目标函数可知，神经网络是基于经验风险最小化原则的学习算法，因而有一些固有的缺陷，比如层数和神经元个数难以确定，容易陷入局部极小，还有过拟合现象等。</p><ol start="2"><li>神经网络的优缺点</li></ol><p><strong>优点:</strong></p><p>(1) 由于神经网络可以有多个非线性的层，因此对非常适合对比较复杂的非线性关系建模；</p><p>(2) 神经网络中的数据结构基本上对学习任何类型的特征变量关系都非常灵活；</p><p>(3) 研究表明，为网络提供更多的训练数据（不管是增加全新的数据集还是对原始数据集进行扩张）可以提高网络性能。</p><p><strong>缺点:</strong></p><p>(1) 网络的训练可能非常具有挑战性和计算密集性，需要大量参数（网络拓扑、阈值）；</p><p>(2) 模型较复杂，结果难以解释；</p><p>(3) 网络的高性能需要大量的数据来实现，在“少量数据”情况下通常不如其他机器学习算法的性能。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>常用的分类算法</div><div>https://fulequn.github.io/2020/10/Article202010081/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2020年10月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2020/10/Article202010082/" title="Failed to start LSB：Bring up/down错误解决办法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Failed to start LSB：Bring up/down错误解决办法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/10/Article202010025/" title="R语言中plot函数合集"><span class="hidden-mobile">R语言中plot函数合集</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>