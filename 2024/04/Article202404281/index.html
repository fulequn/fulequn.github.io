<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="算法  美团0427笔试 美团笔试，上强度了！（0427春招实习笔试真题解析）  1 小美换团 小美拿到了一个字符串，她准备把其中所有的&quot;mei&quot;子串替换为&quot;tuan&quot;子串，你能帮帮她吗？ 输入描述 一个仅由小写字母组成的字符串。长度不超100000 输出描述 修改后的字符串。 示例 1 输入 meituan 输出 tuantuan 思路与代码 打卡题。直"><meta property="og:type" content="article"><meta property="og:title" content="2024.4.28 美团笔试复盘"><meta property="og:url" content="https://fulequn.github.io/2024/04/Article202404281/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="算法  美团0427笔试 美团笔试，上强度了！（0427春招实习笔试真题解析）  1 小美换团 小美拿到了一个字符串，她准备把其中所有的&quot;mei&quot;子串替换为&quot;tuan&quot;子串，你能帮帮她吗？ 输入描述 一个仅由小写字母组成的字符串。长度不超100000 输出描述 修改后的字符串。 示例 1 输入 meituan 输出 tuantuan 思路与代码 打卡题。直"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-04-28T04:47:17.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:08.046Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><title>2024.4.28 美团笔试复盘 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="2024.4.28 美团笔试复盘"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-04-28 12:47" pubdate>2024年4月28日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>32 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">2024.4.28 美团笔试复盘</h1><div class="markdown-body"><h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><h2 id="美团0427笔试"><a class="markdownIt-Anchor" href="#美团0427笔试"></a> 美团0427笔试</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KLzXH5y0unAKT8zvoSLMxA">美团笔试，上强度了！（0427春招实习笔试真题解析）</a></p><h3 id="1-小美换团"><a class="markdownIt-Anchor" href="#1-小美换团"></a> <strong>1 小美换团</strong></h3><p>小美拿到了一个字符串，她准备把其中所有的&quot;mei&quot;子串替换为&quot;tuan&quot;子串，你能帮帮她吗？</p><p><strong>输入描述</strong></p><p>一个仅由小写字母组成的字符串。长度不超100000</p><p><strong>输出描述</strong></p><p>修改后的字符串。</p><p><strong>示例 1</strong></p><p><strong>输入</strong></p><p>meituan</p><p><strong>输出</strong></p><p>tuantuan</p><p><strong>思路与代码</strong></p><p>打卡题。直接模拟即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">input</span>().replace(<span class="hljs-string">&quot;mei&quot;</span>,<span class="hljs-string">&quot;tuan&quot;</span>)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><h3 id="2-小美的特殊矩形"><a class="markdownIt-Anchor" href="#2-小美的特殊矩形"></a> <strong>2 小美的特殊矩形</strong></h3><p>小美拿到了一个字符矩阵，她定义一个矩形区域是“特殊的”，当且仅当这个矩形区域中没有两个相同的字符。 现在小美想知道，有多少个2行2列的矩阵区域是特殊的？</p><p><strong>输入描述</strong></p><p>第一行输入两个正整数n,m，代表矩阵的行数和列数。</p><p>接下来的n行，每行输入一个长度为m的、仅由小写字母组成的字符串，代表小美拿到的字符矩阵。</p><p>1&lt;=n,m&lt;=200</p><p><strong>输出描述</strong></p><p>一个整数，代表&quot;特殊的&quot;矩形区域的数量。</p><p><strong>示例 1</strong></p><p><strong>输入</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">abb</span><br><span class="hljs-attribute">aac</span><br><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><p>0</p><p><strong>思路与代码</strong></p><p>模拟题。 直接枚举所有的2*2的子矩阵，判断是否存在重复的字符即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">n,m = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>matrix = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>):<br>        s = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>                s.add(matrix[i+x][j+y])<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">4</span>:<br>            res += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h3 id="3-小美的数组合并"><a class="markdownIt-Anchor" href="#3-小美的数组合并"></a> <strong>3 小美的数组合并</strong></h3><p>小美拿到了一个数组，她每次操作可以将两个相邻元素ai合并为一个元素，合并后的元素为原来两个元素之和。小美希望最终数组的最小值不小于k。她想知道有多少种不同的合并结果？</p><p><strong>输入描述</strong></p><p>第一行输入两个正整数n,k，代表数组大小和数组的最大值。</p><p>第二行输入个正整数ai，代表小美拿到的数组。</p><p>1&lt;=n,k,ai&lt;=200</p><p><strong>输出描述</strong></p><p>输出一个整数，代表小美可以得到多少种不同的结果。由于结果可能很大，输出对10^9+7取模的结果。</p><p><strong>示例 1</strong></p><p><strong>输入</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><p>4</p><p><strong>说明</strong></p><p>可能得到的数组有：[5,4,5]、[9,5]、[5,9]、[14]这四种。</p><p><strong>思路与代码</strong></p><p>动态规划。</p><p>对于每一个数字来说，如果当前和是小于k的，那么只能选择合并；否则的话，合并和不合并都可以。</p><p><code>f[i,j]</code>考虑i往后的数字，当前和是p，组成满足条件的方案数有多少。</p><p>推导如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">if j&gt;=k: <br>	f<span class="hljs-comment">[i,j]</span> += f<span class="hljs-comment">[i+1,j+a<span class="hljs-comment">[i]</span>]</span> + f<span class="hljs-comment">[i+1,a<span class="hljs-comment">[i]</span>]</span> <br>else:  <br>	f<span class="hljs-comment">[i,j]</span> = f<span class="hljs-comment">[i+1,j+a<span class="hljs-comment">[i]</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取输入的整数 n 和 k</span><br>n, k = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><span class="hljs-comment"># 读取输入的数组 arr，并将其转换为整数列表</span><br>arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 定义一个常量 MOD，用于在计算过程中取模以避免整数溢出</span><br>MOD = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><br><span class="hljs-comment"># 初始化动态规划数组 dp，其大小为 (n+1) x (sum(arr)+1)，所有值初始化为 -1</span><br><span class="hljs-comment"># dp[i][j] 表示在考虑前 i 个数，当前取到的总和为 j 时的方法数</span><br>dp = [[-<span class="hljs-number">1</span>] * (<span class="hljs-built_in">sum</span>(arr) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-comment"># 定义深度优先搜索函数 dfs，参数 i 表示当前考虑的数组元素索引，参数 p 表示当前的累计和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, p</span>):<br>    <span class="hljs-comment"># 如果已经到达数组末尾，则根据当前累计和 p 是否大于等于 k 来返回 1 或 0</span><br>    <span class="hljs-keyword">if</span> i == n:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> p &gt;= k <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 如果当前状态已经计算过，则直接返回结果</span><br>    <span class="hljs-keyword">if</span> dp[i][p] != -<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> dp[i][p]<br><br>    <span class="hljs-comment"># 初始化方法数 cnt 为 0</span><br>    cnt = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 如果当前累计和 p 大于等于 k，则可以选择取当前元素，或者不取</span><br>    <span class="hljs-keyword">if</span> p &gt;= k:<br>        cnt += dfs(i + <span class="hljs-number">1</span>, arr[i])  <span class="hljs-comment"># 不取当前元素的情况</span><br>        cnt += dfs(i + <span class="hljs-number">1</span>, p + arr[i])  <span class="hljs-comment"># 取当前元素的情况</span><br>    <span class="hljs-comment"># 如果当前累计和 p 小于 k，则只能选择取当前元素</span><br>    <span class="hljs-keyword">else</span>:<br>        cnt += dfs(i + <span class="hljs-number">1</span>, p + arr[i])<br><br>    <span class="hljs-comment"># 在计算过程中，为了减少计算量，每次加和后都进行取模操作</span><br>    cnt %= MOD<br>    <span class="hljs-comment"># 将当前状态的计算结果存储在 dp 数组中，以便后续使用</span><br>    dp[i][p] = cnt<br>    <span class="hljs-comment"># 返回当前状态的方法数</span><br>    <span class="hljs-keyword">return</span> dp[i][p]<br><br><span class="hljs-comment"># 调用 dfs 函数，从索引 0 开始，初始累计和为 0，并打印结果</span><br><span class="hljs-built_in">print</span>(dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>这个的终结条件还是比较难想出来的。看最后一个的结果，然后进行回收。重点是中间进行递归的条件，如果当前累计和 p 大于等于 k，则可以选择取当前元素，或者不取；如果当前累计和 p 小于 k，则只能选择取当前元素。</p><p>这个动态规划的数组大小也是比较重要的一个，dp[i][j] 表示在考虑前 i 个数，当前取到的总和为 j 时的方法数。</p><h3 id="4-小美的树上联通块"><a class="markdownIt-Anchor" href="#4-小美的树上联通块"></a> <strong>4 小美的树上联通块</strong></h3><p>小美拿到了一棵树，其中有一些节点被染成红色。</p><p>小美定义一个红色连通块的权值为：所有节点编号乘积的因子数量。</p><p>小美想知道，所有红色连通块的权值之和是多少？由于答案过大，请对10^9+7取模。</p><p><strong>输入描述</strong></p><p>第一行输入一个正整数n，代表节点数量。</p><p>第二行输入一个长度为n的、仅由’R’和’W’组成的字符串，第i个字符为’R’代表i号节点被染成红色，'W’代表未被染色。保证至少有一个节点被染成红色。</p><p>接下来的n-1行，每行输入2个正整数u,v，代表u号节点和v号节点有一条边连接。</p><p>1&lt;=n&lt;=10^5</p><p>1&lt;=u,v&lt;=n</p><p><strong>输出描述</strong></p><p>一个整数，代表所有红色连通块的权值之和。</p><p><strong>示例 1</strong></p><p><strong>输入</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">WRR</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><p>4</p><p><strong>说明</strong></p><p>只有一个红色连通块，权值为6的因子数量：1、2、3、6共4个。</p><p><strong>思路与代码</strong></p><p>树的遍历+因子定理。</p><p>公式1：因子计算，算乘积的因子数(k1+1)×(k2+1)×…×(kr+1)，其中k1,k2,…,kr 是各个质因数的总幂次。</p><p>所以我们dfs遍历每一个红色的节点，然后分解每一个节点的质因子，统计当前连通块的质因子的数量，使用公式1进行运算即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 读取输入的整数 n，表示节点的数量</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-comment"># 读取输入的字符串 colors，表示每个节点的颜色，&#x27;R&#x27; 表示红色，&#x27;W&#x27; 表示白色</span><br>colors = <span class="hljs-built_in">input</span>()<br><span class="hljs-comment"># 初始化邻接表 graph，表示图中的边</span><br>graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-comment"># 读取 n-1 行输入，构建树的邻接表</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>    u, v = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    graph[u].append(v)<br>    graph[v].append(u)<br><br><span class="hljs-comment"># 定义一个大数 MOD，用于在计算过程中取模</span><br>MOD = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><br><span class="hljs-comment"># 定义 get_factors 函数，用于求一个数的所有质因子</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_factors</span>(<span class="hljs-params">n</span>):<br>    prime_factors = []<br>    <span class="hljs-comment"># 将 n 除以 2，直到 n 为奇数</span><br>    <span class="hljs-keyword">while</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        prime_factors.append(<span class="hljs-number">2</span>)<br>        n //= <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 从 3 开始到 n 的平方根，每次增加 2（跳过偶数），检查每个数是否是 n 的质因子</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(n ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">while</span> n % i == <span class="hljs-number">0</span>:<br>            prime_factors.append(i)<br>            n //= i<br>    <span class="hljs-comment"># 如果 n 大于 2，说明 n 是质数，将其加入质因子列表</span><br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">2</span>:<br>        prime_factors.append(n)<br>    <span class="hljs-keyword">return</span> prime_factors<br><br><span class="hljs-comment"># 初始化一个布尔数组 vst，用于标记节点是否已访问</span><br>vst = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义 dfs 函数，用于深度优先搜索图中的节点，并计算质因子的个数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u, f, factors</span>):<br>    vst[u] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 标记节点 u 为已访问</span><br>    primes = get_factors(u)  <span class="hljs-comment"># 获取节点 u 的质因子</span><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes:  <span class="hljs-comment"># 对每个质因子进行计数</span><br>        factors[p] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:  <span class="hljs-comment"># 遍历节点 u 的所有邻居节点</span><br>        <span class="hljs-keyword">if</span> v == f <span class="hljs-keyword">or</span> colors[v - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;W&#x27;</span>:  <span class="hljs-comment"># 如果是父亲节点或颜色为白色，则跳过</span><br>            <span class="hljs-keyword">continue</span><br>        dfs(v, u, factors)  <span class="hljs-comment"># 对邻居节点进行深度优先搜索</span><br>    <span class="hljs-keyword">return</span> factors  <span class="hljs-comment"># 返回质因子计数</span><br><br>res = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化结果变量</span><br><span class="hljs-comment"># 从 1 到 n 遍历每个节点</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> colors[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;R&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> vst[i]:  <span class="hljs-comment"># 如果节点颜色为红色且未访问</span><br>        factors = dfs(i, -<span class="hljs-number">1</span>, defaultdict(<span class="hljs-built_in">int</span>))  <span class="hljs-comment"># 从节点 i 开始进行深度优先搜索，并计算质因子个数</span><br>        ans = <span class="hljs-number">1</span>  <span class="hljs-comment"># 初始化答案变量</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> factors:  <span class="hljs-comment"># 对每个质因子进行处理</span><br>            ans = ans * (factors[p] + <span class="hljs-number">1</span>) % MOD  <span class="hljs-comment"># 更新答案</span><br>        res = (res + ans) % MOD  <span class="hljs-comment"># 更新结果变量</span><br><br><span class="hljs-comment"># 打印最终结果</span><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>首先，这个就得先理解题意，红色连通块的权值为所有节点编号乘积的因子数量。也就是节点编号相乘，之后再求因子数量。例如，4的因子为2、2，也就是获取对应的质因子数目。</p><p>这个因子定理是挺需要记住的，他的核心逻辑就是先统计每个因子的数目，例如2有k1个、3有个k2个，以此类推。最终，乘积的因子数(k1+1)×(k2+1)×…×(kr+1)，其中k1,k2,…,kr 是各个质因数的总幂次。</p><p>这里还有一个记录是否访问过的数组，如果访问过了就代表这个节点在这个联通块中，在刚才的计算中以及考虑进去了，就不需要重新考虑了。也就可以跳过。</p><h3 id="5-小苯的树上询问"><a class="markdownIt-Anchor" href="#5-小苯的树上询问"></a> <strong>5 小苯的树上询问</strong></h3><p>小苯有一个 n 个节点的无向树，每条边都有权重 wi，他将进行 q 次操作，每次操作是以下之一：</p><ol><li>删除第 i 条边。</li><li>询问从 u 号点到 v 号点的最短路径上所有边的边权异或和。</li></ol><p>小苯希望你帮他处理完所有的操作，并对所有操作 2 ，输出对应的异或和。</p><p><strong>输入描述</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">第一行两个正整数 n,<span class="hljs-selector-tag">q</span> (<span class="hljs-number">1</span>&lt;=q&lt;=n&lt;=<span class="hljs-number">2</span>*<span class="hljs-number">10</span>^<span class="hljs-number">5</span>)。<br>接下来 n-<span class="hljs-number">1</span> 行，每行三个正整数 ui,vi,<span class="hljs-built_in">wi</span>(<span class="hljs-number">1</span>&lt;=ui,vi&lt;=n), (ui != vi), (<span class="hljs-number">1</span>&lt;=wi&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>)，表示 ui 到 vi 连了一条权重为 wi 的边。<br>接下来 <span class="hljs-selector-tag">q</span> 行，每行代表一次操作，首先输入一个正整数 <span class="hljs-built_in">op</span>(<span class="hljs-number">1</span>&lt;=op&lt;=<span class="hljs-number">2</span>) 表示操作种类。<br>如果 op=<span class="hljs-number">1</span>，则再输入一个正整数 <span class="hljs-selector-tag">i</span> 表示删除第 <span class="hljs-selector-tag">i</span> 条边。（保证每条边最多被删除一次）<br>如果 op=<span class="hljs-number">2</span>，则再输入两个正整数 u,<span class="hljs-built_in">v</span>(<span class="hljs-number">1</span>&lt;=u,v&lt;=n)，表示询问 u 号点到 v 号点的最短路径中，所有边权的异或和。<br>（注意：如果从 u 没法到达 v，则输出 -<span class="hljs-number">1</span>。）<br><br></code></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>输出包含若干行。</p><p>每行一个整数，对于每次操作 2，输出 u 到 v 的最短路径上所有边权的异或和，路径不存在输出 -1。</p><p><strong>示例 1</strong></p><p><strong>输入</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">1<br>0<br>0<br><span class="hljs-deletion">-1</span><br><br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">样例的树如图所示，前三次询问的结果分别为：</span><br><span class="hljs-attr">1 号点到 2 号点路径异或和为：1</span><br><span class="hljs-attr">1 号点到 4 号点路径异或和为：1 ^ 2 ^ 3 </span>=<span class="hljs-string"> 0</span><br><span class="hljs-string">4 号点到 5 号点路径异或和为：3 ^ 3 = 0</span><br><span class="hljs-string">第五步操作删除第 2 条边，即变为下图：</span><br><span class="hljs-string"></span><br><span class="hljs-string">接着询问 1 好点到 4 号点的路径异或和，由于无法到达，因此输出 -1。</span><br></code></pre></td></tr></table></figure><p><strong>思路与代码</strong></p><p>lca（最近公共祖先）+倍增优化+并查集+逆向思维。</p><p>tip1：树上的最短路其实就是两个点的路径。 tip2：异或运算符合交换律。</p><p>思路如下： 1.对于删除的边，我们可以使用并查集+逆向遍历来判断是否连通。 2.对于连通的点，我们使用lca算法来检查两个节点之间的最近公共祖先，并且记录路径的异或和的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取输入的整数 n 和 q</span><br>n, q = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 初始化邻接表 G，表示图中的边</span><br>G = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-comment"># 初始化边的列表 edges，用于存储所有的边</span><br>edges = []<br><br><span class="hljs-comment"># 读取 n-1 行输入，构建图的邻接表和边的列表</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>    u, v, w = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    edges.append((u, v, w))<br>    G[u].append((v, w))<br>    G[v].append((u, w))<br><br><span class="hljs-comment"># 初始化操作列表 ops，用于存储 q 个操作</span><br>ops = []<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q):<br>    ops.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())))<br><br><span class="hljs-comment"># 定义常量 N，表示节点的总数加 1</span><br>N = n + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 初始化全局变量</span><br><span class="hljs-comment"># pre 数组，用于存储到达每个节点的路径上的异或和</span><br><span class="hljs-comment"># par 数组，用于存储重根路径上的父节点</span><br><span class="hljs-comment"># bit 数组，用于存储深度的二进制表示中每一位的值</span><br><span class="hljs-comment"># f 数组，用于存储重根路径上的祖先节点</span><br><span class="hljs-comment"># depth 数组，用于存储每个节点的深度</span><br>pre = [<span class="hljs-number">0</span>] * N<br>par = [<span class="hljs-number">0</span>] * N<br>bit = [<span class="hljs-number">0</span>] * <span class="hljs-number">30</span><br>f = [[<span class="hljs-number">0</span>] * <span class="hljs-number">30</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>depth = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-comment"># 定义 dfs 函数，用于深度优先搜索，计算每个节点的深度和重根路径上的祖先节点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u, parent</span>):<br>    depth[u] = depth[parent] + <span class="hljs-number">1</span><br>    f[u][<span class="hljs-number">0</span>] = parent<br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 利用二进制提升，计算更高层次的祖先节点</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> bit[i] &lt;= depth[u]:<br>        f[u][i] = f[f[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>]<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 遍历节点 u 的所有邻居节点</span><br>    <span class="hljs-keyword">for</span> v, w <span class="hljs-keyword">in</span> G[u]:<br>        <span class="hljs-keyword">if</span> v != parent:<br>            dfs(v, u)<br><br><span class="hljs-comment"># 定义 lca 函数，用于计算两个节点的最近公共祖先</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-comment"># 确保 x 的深度小于等于 y 的深度</span><br>    <span class="hljs-keyword">if</span> depth[x] &lt; depth[y]:<br>        x, y = y, x<br>    <span class="hljs-comment"># 从高层次到低层次，检查两个节点的祖先节点是否相同</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">29</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> depth[x] - depth[y] &gt;= bit[i]:<br>            x = f[x][i]<br>    <span class="hljs-comment"># 如果 x 和 y 相等，则它们是同一个节点，返回 x</span><br>    <span class="hljs-keyword">if</span> x == y:<br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-comment"># 从高层次到低层次，将 x 和 y 同时上溯，直到它们的祖先节点不相同</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">29</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> f[x][i] != f[y][i]:<br>            x = f[x][i]<br>            y = f[y][i]<br>    <span class="hljs-comment"># 返回 x 和 y 的最近公共祖先</span><br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 定义 dfs_xor 函数，用于计算到达每个节点的路径上的异或和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_xor</span>(<span class="hljs-params">u, fa</span>):<br>    par[u] = fa<br>    <span class="hljs-keyword">for</span> v, w <span class="hljs-keyword">in</span> G[u]:<br>        <span class="hljs-keyword">if</span> v != fa:<br>            pre[v] = pre[u] ^ w<br>            dfs_xor(v, u)<br><br><span class="hljs-comment"># 从节点 1 开始进行深度优先搜索，计算深度和重根路径上的祖先节点</span><br>dfs(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 计算到达每个节点的路径上的异或和</span><br>dfs_xor(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 初始化并查集的 parent 数组，用于存储节点的父节点</span><br>parent = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-comment"># 定义 find 函数，用于查找节点 x 的根节点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> parent[x] != x:<br>        parent[x] = find(parent[x])<br>    <span class="hljs-keyword">return</span> parent[x]<br><br><span class="hljs-comment"># 定义 union 函数，用于合并两个节点的集合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    x, y = find(x), find(y)<br>    <span class="hljs-keyword">if</span> x == y:<br>        <span class="hljs-keyword">return</span><br>    parent[x] = y<br><br><span class="hljs-comment"># 初始化删除边的集合 del_edges</span><br>del_edges = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> ops:<br>    <span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>        del_edges.add(op[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 逆向遍历边的列表 edges，将未被删除的边加入到并查集中</span><br><span class="hljs-keyword">for</span> i, edge <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(edges):<br>    <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> del_edges:<br>        union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 逆向遍历操作列表 ops，处理每个操作</span><br>ops.reverse()<br>ans = []<br><span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> ops:<br>    <span class="hljs-keyword">if</span> op[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 如果是删除边的操作，将对应的边加入到并查集中</span><br>        u, v, w = edges[op[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>]<br>        union(u, v)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 如果是查询操作，计算并返回两个节点的异或和</span><br>        u, v = op[<span class="hljs-number">1</span>], op[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> find(u) != find(v):<br>            ans.append(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            p = lca(u, v)<br>            c = par[p]<br>            ans.append(pre[u] ^ pre[p] ^ pre[v] ^ pre[c])<br><br><span class="hljs-comment"># 逆向遍历答案列表 ans，输出每个操作的结果</span><br>ans.reverse()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ans)))<br><br></code></pre></td></tr></table></figure><p>这题不看了，遇到基本做不出来。</p></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>2024.4.28 美团笔试复盘</div><div>https://fulequn.github.io/2024/04/Article202404281/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年4月28日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/04/Article202404291/" title="2024.4.29 计算机基础+算法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">2024.4.29 计算机基础+算法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/03/Article202403201/" title="Windows环境下Mysql安装与密码设置"><span class="hidden-mobile">Windows环境下Mysql安装与密码设置</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>