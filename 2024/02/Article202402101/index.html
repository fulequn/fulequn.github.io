<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="面经  1 南京小米Java开发二面 小米南京——Java二面_牛客网 1.runable和Thread的区别 他们两个除了最主要的区别：一个是接口，一个是实现类。常用接口可以避免单继承的局限性外，还有继承Thread类的方式可能会导致类的局部变量不能正确的被共享。因为每个线程都是一个独立的对象，它们之间不能共享实例变量，如果需要共享变量，就必须使用静态变量或共享对象锁。而使用Runnable接"><meta property="og:type" content="article"><meta property="og:title" content="2024.2.10 面经+Java基础"><meta property="og:url" content="https://fulequn.github.io/2024/02/Article202402101/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="面经  1 南京小米Java开发二面 小米南京——Java二面_牛客网 1.runable和Thread的区别 他们两个除了最主要的区别：一个是接口，一个是实现类。常用接口可以避免单继承的局限性外，还有继承Thread类的方式可能会导致类的局部变量不能正确的被共享。因为每个线程都是一个独立的对象，它们之间不能共享实例变量，如果需要共享变量，就必须使用静态变量或共享对象锁。而使用Runnable接"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232138669.png"><meta property="article:published_time" content="2024-02-10T13:14:25.000Z"><meta property="article:modified_time" content="2024-05-30T00:16:54.000Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232138669.png"><title>2024.2.10 面经+Java基础 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="2024.2.10 面经+Java基础"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-02-10 21:14" pubdate>2024年2月10日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>4.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>39 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">2024.2.10 面经+Java基础</h1><div class="markdown-body"><h1 id="面经"><a class="markdownIt-Anchor" href="#面经"></a> 面经</h1><h2 id="1-南京小米java开发二面"><a class="markdownIt-Anchor" href="#1-南京小米java开发二面"></a> 1 南京小米Java开发二面</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/feed/main/detail/a220bfe1a8c949eab8b33162eaada8f3?sourceSSR=search">小米南京——Java二面_牛客网</a></p><p><strong>1.runable和Thread的区别</strong></p><p>他们两个除了最主要的区别：一个是接口，一个是实现类。常用接口可以避免单继承的局限性外，还有继承Thread类的方式可能会导致类的局部变量不能正确的被共享。因为每个线程都是一个独立的对象，它们之间不能共享实例变量，如果需要共享变量，就必须使用静态变量或共享对象锁。而使用Runnable接口的方式，多个线程可以共享同一个Runnable实例，从而共享实例变量。</p><p>使用Runnable接口可以更好的体现面向对象编程的思想，把任务和线程分离开来。任务可以看作是一个对象，而线程可以看作是该对象的执行者。这样就可以更好的实现模块化设计，提高代码的可重用性和可维护性。</p><p>使用Runnable接口可以更好地处理多个线程之间的交互和协作。因为Runnable实例可以作为参数传递给Thread构造函数，线程可以共享同一个Runnable实例，并且多个线程可以同时执行同一个Runnable实例的不同方法，从而实现多个线程之间的交互和协作。总的来说，使用Runnable接口的方式更加灵活和通用，可以实现更多的多线程编程场景，更好的体现面向对象编程的思想，提高代码的可重用性和可维护性。但是，使用Thread类的方式也有其适用的场景，例如在一些简单的多线程编程场景中可以使用继承Thread类的方式来实现。</p><p><strong>2.final关键字的作用，如何实现不能被修改</strong></p><p><strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li><li>final 修饰的方法不能被重写；</li><li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li></ol><p>说明：使用 final 方法的原因有两个：</p><ol><li>把方法锁定，以防任何继承类修改它的含义；</li><li>效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。</li></ol><p><strong>3.java反射</strong></p><p>反射机制是一种让我们在运行时分析类以及执行类中方法的能力。通过反射，我们可以获取任意一个类的所有属性和方法，并调用它们。它使得我们的代码更加灵活，为各种框架提供了便利。虽然反射带来了灵活性，但也增加了安全问题，并且性能稍差。在实际开发中，大量框架如Spring、MyBatis都广泛使用了反射。反射的应用场景包括动态代理、注解实现等，通过反射可以获取类、属性、方法以及方法参数上的注解，进而实现各种高级功能。</p><p><strong>4.使用Executors创建有10个线程的线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zr.demo01;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用Executors创建有10个线程的线程池,该线程池的线程都是待机状态,所以避免了开启新线程的时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ZR</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Seventeenth</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		MyRunable myRunable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunable</span>();<br>		<br>		<span class="hljs-comment">//有10个线程的线程池</span><br>		<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>		<br>		<span class="hljs-comment">//使用4个线程</span><br>		service.submit(myRunable);<br>		service.submit(myRunable);<br>		service.submit(myRunable);<br>		service.submit(myRunable);<br>		<br>		<span class="hljs-comment">//关闭线程池</span><br>		service.shutdown();<br>	&#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>			<span class="hljs-keyword">synchronized</span> (MyRunable.class) &#123;<br>				<span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">100</span>) &#123;<br>					System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;-------------------&gt;&quot;</span>+i);<br>					i++;<br>				&#125;<span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">return</span>;<br>				&#125;<br>			&#125;	<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> Java基础</h1><h2 id="1-抽象类"><a class="markdownIt-Anchor" href="#1-抽象类"></a> 1 抽象类</h2><h3 id="11-概述"><a class="markdownIt-Anchor" href="#11-概述"></a> *1.1 概述</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ：没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h3 id="12-abstract使用格式"><a class="markdownIt-Anchor" href="#12-abstract使用格式"></a> *1.2 abstract使用格式</h3><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><p><strong>1.抽象方法</strong></p><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表)；<br></code></pre></td></tr></table></figure><p><strong>2.抽象类</strong></p><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名字 &#123; <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h3 id="13-抽象类的特征"><a class="markdownIt-Anchor" href="#13-抽象类的特征"></a> 1.3 抽象类的特征</h3><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p><p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p><p><strong>有失：抽象类失去了创建对象的能力。</strong></p><p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。</p><h3 id="14-抽象类的细节"><a class="markdownIt-Anchor" href="#14-抽象类的细节"></a> 1.4 抽象类的细节</h3><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h3 id="15-抽象类存在的意义"><a class="markdownIt-Anchor" href="#15-抽象类存在的意义"></a> *1.5 抽象类存在的意义</h3><p>抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类一定要按照规定的格式进行重写。</p><h2 id="2-接口"><a class="markdownIt-Anchor" href="#2-接口"></a> 2 接口</h2><h3 id="21-概述"><a class="markdownIt-Anchor" href="#21-概述"></a> 2.1 概述</h3><p>我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。那么什么是接口呢？<strong>接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的</strong>。</p><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口的定义格式：</span><br>interface 接口名称&#123;<br>    <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br><span class="hljs-comment">// 接口的声明：interface</span><br><span class="hljs-comment">// 接口名称：首字母大写，满足“驼峰模式”</span><br></code></pre></td></tr></table></figure><h3 id="22-接口成分的特点"><a class="markdownIt-Anchor" href="#22-接口成分的特点"></a> *2.2 接口成分的特点</h3><p>在JDK7，包括JDK7之前，接口中的<strong>只有</strong>包含：抽象方法和常量。</p><p><strong>抽象方法</strong></p><p>注意：接口中的抽象方法默认会自动加上public abstract修饰，程序员无需自己手写！！</p><p>按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p><p><strong>常量</strong></p><p>在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。</p><h3 id="23-基本的实现"><a class="markdownIt-Anchor" href="#23-基本的实现"></a> *2.3 基本的实现</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p><p><strong>实现接口的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**接口的实现：</span><br><span class="hljs-comment">    在Java中接口是被实现的，实现接口的类称为实现类。</span><br><span class="hljs-comment">    实现类的格式:*/</span><br>class 类名 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3.</span>..&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类实现接口的要求和意义</strong></p><ol><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="24-接口与接口的多继承"><a class="markdownIt-Anchor" href="#24-接口与接口的多继承"></a> 2.4 接口与接口的多继承</h3><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：</p><p><strong>类与接口是实现关系</strong></p><p><strong>接口与接口是继承关系</strong></p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并。</p><h3 id="25-接口的细节"><a class="markdownIt-Anchor" href="#25-接口的细节"></a> 2.5 接口的细节</h3><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><p>关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li>当两个接口中存在相同抽象方法的时候，该怎么办？</li></ol><blockquote><p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p></blockquote><ol start="2"><li>实现类能不能继承A类的时候，同时实现其他接口呢？</li></ol><blockquote><p>继承的父类，就好比是亲爸爸一样<br>实现的接口，就好比是干爹一样<br>可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p></blockquote><ol start="3"><li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li></ol><blockquote><p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p></blockquote><ol start="4"><li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li></ol><blockquote><p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。<br>处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p></blockquote><ol start="5"><li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li></ol><blockquote><p>可以在接口跟实现类中间，新建一个中间类（适配器类）<br>让这个适配器类去实现接口，对接口里面的所有的方法做空重写。<br>让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。<br>因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p></blockquote><h2 id="3-内部类"><a class="markdownIt-Anchor" href="#3-内部类"></a> 3 内部类</h2><h3 id="31-概述"><a class="markdownIt-Anchor" href="#31-概述"></a> 3.1 概述</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><p><strong>什么时候使用内部类</strong></p><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用：</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h3 id="32-内部类的分类"><a class="markdownIt-Anchor" href="#32-内部类的分类"></a> 3.2 内部类的分类</h3><p>按定义的位置来分</p><ol><li><strong>成员内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)；</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)；</li><li><strong>局部内部类</strong>，类定义在方法内；</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li></ol><h3 id="33-成员内部类"><a class="markdownIt-Anchor" href="#33-成员内部类"></a> 3.3 成员内部类</h3><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。例如，ArrayList类就包含了一个实现了Iterator的内部类。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类。 <span class="hljs-comment">// 访问内部类的类型都是用 外部类.内部类</span><br></code></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类 变量 = <span class="hljs-keyword">new</span> 外部类（）.new 内部类（）;<br></code></pre></td></tr></table></figure><p>方式二：在外部类中定义一个方法提供内部类的对象</p><p><strong>成员内部类的细节</strong></p><p>编写成员内部类的注意点：</p><ol><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。</li></ol><p><strong>成员内部类内存图</strong></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232138669.png" srcset="/img/loading.gif" lazyload alt="内部类内存图"></p><h3 id="37-静态内部类"><a class="markdownIt-Anchor" href="#37-静态内部类"></a> 3.7 静态内部类</h3><p><strong>静态内部类特点</strong>：</p><ul><li>静态内部类是一种特殊的成员内部类。</li></ul><ul><li>有static修饰，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</li><li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</li><li><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">外部类.内部类。<br></code></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类  变量 = <span class="hljs-keyword">new</span> 外部类.内部类构造器;<br></code></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><h3 id="38-局部内部类"><a class="markdownIt-Anchor" href="#38-局部内部类"></a> 3.8 局部内部类</h3><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">class 外部类名 &#123;<br>	数据类型 变量名;<br>	<br>	修饰符 返回值类型 方法名(参数列表) &#123;<br>		<span class="hljs-comment">// …</span><br>		class 内部类 &#123;<br>			<span class="hljs-comment">// 成员变量</span><br>			<span class="hljs-comment">// 成员方法</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="39-匿名内部类"><a class="markdownIt-Anchor" href="#39-匿名内部类"></a> *3.9 匿名内部类</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或者接口名() &#123;<br>     重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><p>包含了：</p><ul><li><p>继承或者实现关系</p></li><li><p>方法重写</p></li><li><p>创建对象</p></li></ul><p>所以从语法上来讲，这个整体其实是匿名内部类对象</p><p><strong>什么时候用到匿名内部类</strong></p><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用是为了简化代码</strong>。</p><p><strong>匿名内部类前提和格式</strong></p><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>匿名内部类的特点</strong></p><ol><li>定义一个没有名字的内部类；</li><li>这个类实现了父类或者父类接口；</li><li>匿名内部类会创建这个没有名字的类的对象。</li></ol><p><strong>匿名内部类的使用场景</strong></p><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。当你在项目中需要一个临时的小功能，但是又不想专门创建一个新的类来实现它，这时候匿名内部类就派上用场了。</p><p>比如，你在Swing界面中点击按钮后需要执行一些操作，你可以用匿名内部类来写这个按钮的点击事件监听器。或者，你需要在某个方法里开启一个新的线程去做一些事情，你可以使用匿名内部类创建这个线程对象。</p></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>2024.2.10 面经+Java基础</div><div>https://fulequn.github.io/2024/02/Article202402101/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年2月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/02/Article202402111/" title="Git配置代理实现加速"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Git配置代理实现加速</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/02/Article202402071/" title="2024.2.7 Java基础"><span class="hidden-mobile">2024.2.7 Java基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>