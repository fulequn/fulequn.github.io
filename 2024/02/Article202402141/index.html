<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="1 常见API  1.1 Math类 概述 查看API文档，我们可以看到API文档中关于Math类的定义如下：  Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。 Math类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。 要想使用Math类我们就需要先创建该类的对象，那么创建对象就需要借助于"><meta property="og:type" content="article"><meta property="og:title" content="2024.2.14 Java基础"><meta property="og:url" content="https://fulequn.github.io/2024/02/Article202402141/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="1 常见API  1.1 Math类 概述 查看API文档，我们可以看到API文档中关于Math类的定义如下：  Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。 Math类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。 要想使用Math类我们就需要先创建该类的对象，那么创建对象就需要借助于"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021554373.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021554022.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021557651.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021557136.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021601206.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021602977.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605370.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605419.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605771.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605615.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021607827.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021608229.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021609926.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021609572.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021611354.png"><meta property="article:published_time" content="2024-02-14T13:15:55.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:08.002Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021554373.png"><title>2024.2.14 Java基础 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="2024.2.14 Java基础"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-02-14 21:15" pubdate>2024年2月14日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>4.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>39 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">2024.2.14 Java基础</h1><div class="markdown-body"><h1 id="1-常见api"><a class="markdownIt-Anchor" href="#1-常见api"></a> 1 常见API</h1><h2 id="11-math类"><a class="markdownIt-Anchor" href="#11-math类"></a> 1.1 Math类</h2><p><strong>概述</strong></p><p>查看API文档，我们可以看到API文档中关于Math类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021554373.png" srcset="/img/loading.gif" lazyload alt="1576047659085"></p><p>Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。</p><p>Math类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。</p><p>要想使用Math类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对Math类有没有提供对应的构造方法。通过API文档来查看</p><p>一下Math类的成员，如下所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021554022.png" srcset="/img/loading.gif" lazyload alt="1576047846672"></p><p>在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建Math类的对象。同时我们发现Math类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用。在Math类中</p><p><font color="red" size="3"><strong>常见方法介绍</strong></font></p><p>我们要学习的Math的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>					<span class="hljs-comment">// 返回参数的绝对值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>				<span class="hljs-comment">// 返回大于或等于参数的最小整数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>			<span class="hljs-comment">// 返回小于或等于参数的最大整数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">round</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span>				<span class="hljs-comment">// 按照四舍五入返回最接近参数的int类型的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>				<span class="hljs-comment">// 获取两个int值中的较大值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>				<span class="hljs-comment">// 获取两个int值中的较小值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">pow</span> <span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span>	<span class="hljs-comment">// 计算a的b次幂的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">random</span><span class="hljs-params">()</span>					<span class="hljs-comment">// 返回一个[0.0,1.0)的随机值</span><br></code></pre></td></tr></table></figure><h2 id="12-system类"><a class="markdownIt-Anchor" href="#12-system类"></a> 1.2 System类</h2><p><strong>概述</strong></p><p>查看API文档，我们可以看到API文档中关于System类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021557651.png" srcset="/img/loading.gif" lazyload alt="1576049347968"></p><p>System类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。</p><p>System包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。</p><p>要想使用System类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对System类有没有提供对应的构造方法。通过API文档来</p><p>查看一下System类的成员，如下所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021557136.png" srcset="/img/loading.gif" lazyload alt="1576049535584"></p><p>在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建System类的对象。同时我们发现System类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用。</p><p><font color="red" size="3"><strong>常见方法介绍</strong></font></p><p>我们要学习的System类中的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">currentTimeMillis</span><span class="hljs-params">()</span>			<span class="hljs-comment">// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>				<span class="hljs-comment">// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos, Object dest, <span class="hljs-type">int</span> destPos, <span class="hljs-type">int</span> length)</span>; <span class="hljs-comment">// 进行数值元素copy</span><br></code></pre></td></tr></table></figure><p><font color="red" size="3"><strong>案例演示</strong></font></p><p>接下来我们就来通过一些案例演示一下这些方法的特点。</p><p><font color="blue" size="2"><strong>案例1</strong></font>：演示currentTimeMillis方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemDemo01</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 获取当前时间所对应的毫秒值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">millis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;当前时间所对应的毫秒值为：&quot;</span> + millis);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序进行测试，控制台的输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">当前时间所对应的毫秒值为：<span class="hljs-number">1576050298343</span><br></code></pre></td></tr></table></figure><p>获取到当前时间的毫秒值的意义：我们常常来需要统计某一段代码的执行时间。此时我们就可以在执行这段代码之前获取一次时间，在执行完毕以后再次获取一次系统时间，然后计算两个时间的差值，</p><p>这个差值就是这段代码执行完毕以后所需要的时间。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//判断1~100000之间有多少个质数</span><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> isPrime2(i);<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//获取程序运行的总时间</span><br>        System.out.println(end - start); <span class="hljs-comment">//方式一：1514 毫秒  方式二：71毫秒</span><br>    &#125;<br><br>    <span class="hljs-comment">//以前判断是否为质数的方式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime1</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; number; i++) &#123;<br>            <span class="hljs-keyword">if</span> (number % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//改进之后判断是否为质数的方式（效率高）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime2</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= Math.sqrt(number); i++) &#123;<br>            <span class="hljs-keyword">if</span> (number % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="blue" size="2"><strong>案例3</strong></font>：演示arraycopy方法</p><p>方法参数说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// src: 	 源数组</span><br><span class="hljs-comment">// srcPos：  源数值的开始位置</span><br><span class="hljs-comment">// dest：    目标数组</span><br><span class="hljs-comment">// destPos： 目标数组开始位置</span><br><span class="hljs-comment">// length:   要复制的元素个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos, Object dest, <span class="hljs-type">int</span> destPos, <span class="hljs-type">int</span> length)</span>; <br></code></pre></td></tr></table></figure><p><strong>arraycopy方法底层细节：</strong></p><p>1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错</p><p>2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错</p><p>3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型</p><h2 id="13-runtime类"><a class="markdownIt-Anchor" href="#13-runtime类"></a> *1.3 Runtime类</h2><p>Runtime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息。</p><p><font color="red" size="3"><strong>常见方法介绍</strong></font></p><p>我们要学习的Object类中的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span>		<span class="hljs-comment">//当前系统的运行环境对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>			<span class="hljs-comment">//停止虚拟机</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">availableProcessors</span><span class="hljs-params">()</span>		<span class="hljs-comment">//获得CPU的线程数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxMemory</span><span class="hljs-params">()</span>				    <span class="hljs-comment">//JVM能从系统中获取总内存大小（单位byte）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">totalMemory</span><span class="hljs-params">()</span>				<span class="hljs-comment">//JVM已经从系统中获取总内存大小（单位byte）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">freeMemory</span><span class="hljs-params">()</span>				<span class="hljs-comment">//JVM剩余内存大小（单位byte）</span><br><span class="hljs-keyword">public</span> Process <span class="hljs-title function_">exec</span><span class="hljs-params">(String command)</span> 	<span class="hljs-comment">//运行cmd命令</span><br></code></pre></td></tr></table></figure><h2 id="14-object类"><a class="markdownIt-Anchor" href="#14-object类"></a> *1.4 Object类</h2><p>查看API文档，我们可以看到API文档中关于Object类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021601206.png" srcset="/img/loading.gif" lazyload alt="1576053677194"></p><p>Object类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。</p><p>查看API文档我们可以看到，在Object类中提供了一个无参构造方法，如下所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021602977.png" srcset="/img/loading.gif" lazyload alt="1576053871503"></p><p>但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。</p><p><font color="red" size="3"><strong>常见方法介绍</strong></font></p><p>我们要学习的Object类中的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>				<span class="hljs-comment">//返回该对象的字符串表示形式(可以看做是对象的内存地址值)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>		<span class="hljs-comment">//比较两个对象地址值是否相等；true表示相同，false表示不相同</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>    			<span class="hljs-comment">//对象克隆</span><br></code></pre></td></tr></table></figure><p>toString小结：</p><ol><li>在通过输出语句输出一个对象时，默认调用的就是toString()方法</li><li>输出地址值一般没有意义，我们可以通过重写toString方法去输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -&gt; Generate -&gt; 选择toString）</li><li>toString方法的作用：以良好的格式，更方便的展示对象中的属性值</li><li>一般情况下Jdk所提供的类都会重写Object类中的toString方法</li></ol><p>equals小结：</p><ol><li>默认情况下equals方法比较的是对象的地址值</li><li>比较对象的地址值是没有意义的，因此一般情况下我们都会重写Object类中的equals方法</li></ol><p>对象克隆</p><p>​	把A对象的属性值完全拷贝给B对象，也叫对象拷贝,对象复制</p><p><strong>对象克隆的分类：</strong></p><blockquote><p>深克隆和浅克隆</p></blockquote><p><strong>浅克隆：</strong></p><p>不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来。基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。</p><p>Object类默认的是浅克隆。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605370.png" srcset="/img/loading.gif" lazyload alt="浅克隆"></p><p><strong>深克隆：</strong></p><p>基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605419.png" srcset="/img/loading.gif" lazyload alt="深克隆"></p><h2 id="15-objects类"><a class="markdownIt-Anchor" href="#15-objects类"></a> 1.5 Objects类</h2><p>查看API文档，我们可以看到API文档中关于Objects类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605771.png" srcset="/img/loading.gif" lazyload alt="1576058492444"></p><p>Objects类所在包是在java.util包下，因此在使用的时候需要进行导包。并且Objects类是被final修饰的，因此该类不能被继承。</p><p>Objects类提供了一些对象常见操作的方法。比如判断对象是否相等，判断对象是否为null等等。</p><p>接下来我们来查看一下API文档，看一下Objects类中的成员，如下所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021605615.png" srcset="/img/loading.gif" lazyload alt="1576058659628"></p><p>我们可以发现Objects类中无无参构造方法，因此我们不能使用new关键字去创建Objects的对象。同时我们可以发现Objects类中所提供的方法都是静态的。因此我们可以通过类名直接去调用这些方法。</p><p><font color="red" size="3"><strong>常见方法介绍</strong></font></p><p>我们要重点学习的Objects类中的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(Object o)</span> 					<span class="hljs-comment">// 获取对象的字符串表现形式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span>			<span class="hljs-comment">// 比较两个对象是否相等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNull</span><span class="hljs-params">(Object obj)</span>					<span class="hljs-comment">// 判断对象是否为null</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonNull</span><span class="hljs-params">(Object obj)</span>					<span class="hljs-comment">// 判断对象是否不为null</span><br></code></pre></td></tr></table></figure><p>我们要了解的Objects类中的常见方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">requireNonNull</span><span class="hljs-params">(T obj)</span>					<span class="hljs-comment">// 检查对象是否不为null,如果为null直接抛出异常；如果不是null返回该对象；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">requireNonNullElse</span><span class="hljs-params">(T obj, T defaultObj)</span> <span class="hljs-comment">// 检查对象是否不为null，如果不为null，返回该对象；如果为null返回defaultObj值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">requireNonNullElseGet</span><span class="hljs-params">(T obj, Supplier&lt;? extends T&gt; supplier)</span>	<span class="hljs-comment">// 检查对象是否不为null，如果不为null，返回该对象；如果															 // 为null,返回由Supplier所提供的值</span><br></code></pre></td></tr></table></figure><h2 id="16-biginteger类"><a class="markdownIt-Anchor" href="#16-biginteger类"></a> *1.6 BigInteger类</h2><p>平时在存储整数的时候，Java中默认是int类型，int类型有取值范围：-2147483648 ~ 2147483647。如果数字过大，我们可以使用long类型，但是如果long类型也表示不下怎么办呢？就需要用到BigInteger，可以理解为：大的整数。</p><p>有多大呢？理论上最大到42亿的21亿次方。</p><p>查看API文档，我们可以看到API文档中关于BigInteger类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021607827.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2022-09-04_21-36-01"></p><p>BigInteger所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigInteger类进行大整数的计算</p><p><font color="red" size="3"><strong>构造方法</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">BigInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> num, Random rnd)</span> 		<span class="hljs-comment">//获取随机大整数，范围：[0 ~ 2的num次方-1]</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BigInteger</span><span class="hljs-params">(String val)</span> 				<span class="hljs-comment">//获取指定的大整数，推荐使用这种方式来创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BigInteger</span><span class="hljs-params">(String val, <span class="hljs-type">int</span> radix)</span> 	<span class="hljs-comment">//获取指定进制的大整数</span><br>    <br>下面这个不是构造，而是一个静态方法获取BigInteger对象<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigInteger <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> val)</span> 	<span class="hljs-comment">//静态方法获取BigInteger的对象，内部有优化</span><br></code></pre></td></tr></table></figure><p><strong>构造方法小结：</strong></p><ul><li>如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。</li><li>如果BigInteger表示的超出long的范围，可以用构造方法获取。</li><li>对象一旦创建，BigInteger内部记录的值不能发生改变。</li><li>只要进行计算都会产生一个新的BigInteger对象</li></ul><p><font color="red" size="3"><strong>常见成员方法</strong></font></p><p>BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">add</span><span class="hljs-params">(BigInteger val)</span>					<span class="hljs-comment">//加法</span><br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">subtract</span><span class="hljs-params">(BigInteger val)</span>				<span class="hljs-comment">//减法</span><br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">multiply</span><span class="hljs-params">(BigInteger val)</span>				<span class="hljs-comment">//乘法</span><br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">divide</span><span class="hljs-params">(BigInteger val)</span>				<span class="hljs-comment">//除法</span><br><span class="hljs-keyword">public</span> BigInteger[] divideAndRemainder(BigInteger val)	 <span class="hljs-comment">//除法，获取商和余数</span><br><span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object x)</span> 					    <span class="hljs-comment">//比较是否相同</span><br><span class="hljs-keyword">public</span>  BigInteger <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">int</span> exponent)</span> 					<span class="hljs-comment">//次幂、次方</span><br><span class="hljs-keyword">public</span>  BigInteger max/min(BigInteger val) 				<span class="hljs-comment">//返回较大值/较小值</span><br><span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">intValue</span><span class="hljs-params">(BigInteger val)</span> 					<span class="hljs-comment">//转为int类型整数，超出范围数据有误</span><br></code></pre></td></tr></table></figure><p><strong>底层存储方式</strong></p><p>对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。</p><p>数组中最多能存储元素个数：21亿多</p><p>数组中每一位能表示的数字：42亿多</p><p>理论上，BigInteger能表示的最大数字为：42亿的21亿次方。</p><p>但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。</p><p>存储方式如图所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021608229.png" srcset="/img/loading.gif" lazyload alt="bigInteger的底层原理"></p><h2 id="17-bigdecimal类"><a class="markdownIt-Anchor" href="#17-bigdecimal类"></a> *1.7 BigDecimal类</h2><p>在使用float或者double类型的数据在进行数学运算的时候，很有可能会产生精度丢失问题。我们都知道计算机底层在进行运算的时候，使用的都是二进制数据。当我们在程序中写了一个十进制数据 ，在进行运算的时候，计算机会将这个十进制数据转换成二进制数据，然后再进行运算，计算完毕以后计算机会把运算的结果再转换成十进制数据给我们展示。</p><p>如果我们使用的是整数类型的数据进行计算，那么在把十进制数据转换成二进制数据的时候不会存在精度问题；</p><p>如果我们的数据是一个浮点类型的数据，有的时候计算机并不会将这个数据完全转换成一个二进制数据，而是将这个将其转换成一个无限的趋近于这个十进数的二进制数据；</p><p>这样使用一个不太准确的数据进行运算的时候， 最终就会造成精度丢失。为了提高精度，Java就给我们提供了BigDecimal供我们进行数据运算。</p><p>查看API文档，我们可以看到API文档中关于BigDecimal类的定义如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021609926.png" srcset="/img/loading.gif" lazyload alt="1576132679789"></p><p>BigDecimal所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigDecimal类进行更加精准的数据计算。</p><p><font color="red" size="3"><strong>构造方法</strong></font></p><p>要用BigDecimal类，那么就需要首先学习一下如何去创建BigDecimal的对象。通过查看API文档，我们可以发现Jdk中针对BigDecimal类提供了很多的构造方法，但是最常用的构造方法是：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021609572.png" srcset="/img/loading.gif" lazyload alt="1576134383441"></p><p>了解完常见的构造方法以后，我们接下来就重点介绍一下常见的成员方法。</p><p><font color="red" size="3"><strong>常见成员方法</strong></font></p><p>BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">add</span><span class="hljs-params">(BigDecimal value)</span>				<span class="hljs-comment">// 加法运算</span><br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">subtract</span><span class="hljs-params">(BigDecimal value)</span>		<span class="hljs-comment">// 减法运算</span><br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">multiply</span><span class="hljs-params">(BigDecimal value)</span>		<span class="hljs-comment">// 乘法运算</span><br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal value)</span>			<span class="hljs-comment">// 触发运算</span><br></code></pre></td></tr></table></figure><p>如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。</p><p>针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal divisor, <span class="hljs-type">int</span> scale, <span class="hljs-type">int</span> roundingMode)</span><br></code></pre></td></tr></table></figure><p>上述divide方法参数说明：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">divisor:			除数对应的BigDecimal对象；<br>scale:				精确的位数；<br>roundingMode:		取舍模式；<br>取舍模式被封装到了RoundingMode这个枚举类中（关于枚举我们后期再做重点讲解），在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个：<br><span class="hljs-function"><span class="hljs-title">UP</span><span class="hljs-params">(直接进<span class="hljs-number">1</span>)</span></span> ， <span class="hljs-built_in">FLOOR</span>(直接删除) ， <span class="hljs-built_in">HALF_UP</span>(<span class="hljs-number">4</span>舍五入),我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名<br></code></pre></td></tr></table></figure><p>接下来我们就来演示一下这些取舍模式，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigDecimalDemo02</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用方法</span><br>        method_03() ;<br>    &#125;<br><br>    <span class="hljs-comment">// 演示取舍模式HALF_UP</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method_03</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建两个BigDecimal对象</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.3&quot;</span>) ;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;4&quot;</span>) ;<br>        <span class="hljs-comment">// 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出</span><br>        System.out.println(b1.divide(b2 , <span class="hljs-number">2</span> , RoundingMode.HALF_UP));<br>    &#125;<br><br>    <span class="hljs-comment">// 演示取舍模式FLOOR</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method_02</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建两个BigDecimal对象</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>) ;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>) ;<br>        <span class="hljs-comment">// 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出</span><br>        System.out.println(b1.divide(b2 , <span class="hljs-number">2</span> , RoundingMode.FLOOR));<br>    &#125;<br><br>    <span class="hljs-comment">// 演示取舍模式UP</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method_01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建两个BigDecimal对象</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>) ;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>) ;<br>        <span class="hljs-comment">// 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出</span><br>        System.out.println(b1.divide(b2 , <span class="hljs-number">2</span> , RoundingMode.UP));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小结：后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。</p><p><strong>底层存储方式</strong></p><p>把数据看成字符串，遍历得到里面的每一个字符，把这些字符在ASCII码表上的值，都存储到数组中。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405021611354.png" srcset="/img/loading.gif" lazyload alt="bigdecimal存储原理"></p><h1 id="2-正则表达式"><a class="markdownIt-Anchor" href="#2-正则表达式"></a> 2 正则表达式</h1><h2 id="21-正则表达式-字符类"><a class="markdownIt-Anchor" href="#21-正则表达式-字符类"></a> 2.1 正则表达式-字符类</h2><ul><li>语法示例：</li></ul><ol><li>[abc]：代表a或者b，或者c字符中的一个。</li><li>[^abc]：代表除a,b,c以外的任何字符。</li><li>[a-z]：代表a-z的所有小写字符中的一个。</li><li>[A-Z]：代表A-Z的所有大写字符中的一个。</li><li>[0-9]：代表0-9之间的某一个数字字符。</li><li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li><li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。</li></ol><h2 id="22-正则表达式-逻辑运算符"><a class="markdownIt-Anchor" href="#22-正则表达式-逻辑运算符"></a> 2.2 正则表达式-逻辑运算符</h2><ul><li>语法示例：<ol><li>&amp;&amp;：并且</li><li>| ：或者</li><li>\ ：转义字符</li></ol></li></ul><h2 id="23-正则表达式-预定义字符"><a class="markdownIt-Anchor" href="#23-正则表达式-预定义字符"></a> 2.3 正则表达式-预定义字符</h2><ul><li>语法示例：<ol><li>“.” ： 匹配任何字符。</li><li>“\d”：任何数字[0-9]的简写；</li><li>“\D”：任何非数字[^0-9]的简写；</li><li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li><li>“\S”： 非空白字符：[^\s] 的简写</li><li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li><li>“\W”：非单词字符：[^\w]</li></ol></li></ul><h2 id="24-正则表达式-数量词"><a class="markdownIt-Anchor" href="#24-正则表达式-数量词"></a> 2.4 正则表达式-数量词</h2><ul><li><p>语法示例：</p><ol><li>X? : 0次或1次</li><li>X* : 0次到多次</li><li>X+ : 1次或多次</li><li>X{n} : 恰好n次</li><li>X{n,} : 至少n次</li><li>X{n,m}: n到m次(n和m都是包含的)</li></ol><p>其中，X代表字符。</p></li></ul><p>正则表达式可以应用的场景：</p><ol><li><p><strong>字符串搜索</strong>：检查一个字符串是否包含某种模式的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> pattern.matcher(text).find();<br></code></pre></td></tr></table></figure></li><li><p><strong>字符串替换</strong>：将匹配到的字符串替换为另一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pattern.matcher(text).replaceAll(replacement);<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(String regex,String newStr)</span><br><span class="hljs-comment">//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>数据验证</strong>：验证输入数据的格式，如邮箱、电话号码、日期、密码强度等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> pattern.matcher(text).matches();<br></code></pre></td></tr></table></figure></li><li><p><strong>分割字符串</strong>：根据模式将一个字符串分割成多个子字符串。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] split(String regex)<br><span class="hljs-comment">//参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。</span><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>2024.2.14 Java基础</div><div>https://fulequn.github.io/2024/02/Article202402141/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年2月14日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/02/Article202402151/" title="2024.2.15 Java基础（时间，包装类）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">2024.2.15 Java基础（时间，包装类）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/02/Article202402121/" title="2024.2.12 算法"><span class="hidden-mobile">2024.2.12 算法</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>