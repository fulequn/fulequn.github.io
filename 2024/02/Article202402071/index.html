<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="Java基础  1 封装  1.1 封装的步骤 1.使用 private 关键字来修饰成员变量。 2.使用public修饰getter和setter方法。  1.2 构造方法 在创建对象的时候，给成员变量进行初始化。初始化即赋值的意思。具体的格式如下所示： 123修饰符 类名(形参列表) &#123;    &#x2F;&#x2F; 构造体代码，执行代码&#125; 可以设置私有化构造方法，例如一些工具类就是私有化"><meta property="og:type" content="article"><meta property="og:title" content="2024.2.7 Java基础"><meta property="og:url" content="https://fulequn.github.io/2024/02/Article202402071/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="Java基础  1 封装  1.1 封装的步骤 1.使用 private 关键字来修饰成员变量。 2.使用public修饰getter和setter方法。  1.2 构造方法 在创建对象的时候，给成员变量进行初始化。初始化即赋值的意思。具体的格式如下所示： 123修饰符 类名(形参列表) &#123;    &#x2F;&#x2F; 构造体代码，执行代码&#125; 可以设置私有化构造方法，例如一些工具类就是私有化"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232059169.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232104032.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232104921.png"><meta property="article:published_time" content="2024-02-07T14:55:53.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:07.984Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232059169.jpg"><title>2024.2.7 Java基础 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="2024.2.7 Java基础"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-02-07 22:55" pubdate>2024年2月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>4.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>40 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">2024.2.7 Java基础</h1><div class="markdown-body"><h1 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> Java基础</h1><h2 id="1-封装"><a class="markdownIt-Anchor" href="#1-封装"></a> 1 封装</h2><h3 id="11-封装的步骤"><a class="markdownIt-Anchor" href="#11-封装的步骤"></a> 1.1 封装的步骤</h3><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><h3 id="12-构造方法"><a class="markdownIt-Anchor" href="#12-构造方法"></a> 1.2 构造方法</h3><p>在创建对象的时候，给成员变量进行初始化。初始化即赋值的意思。具体的格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 类名(形参列表) &#123;<br>    <span class="hljs-comment">// 构造体代码，执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以设置私有化构造方法，例如一些工具类就是私有化构造方法，这样就可以不让其他人创建出工具类的实例，而是仅仅使用其中的静态方法。</p><h3 id="13-this关键字的作用"><a class="markdownIt-Anchor" href="#13-this关键字的作用"></a> 1.3 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p><p><strong>用于普通的gettter与setter方法</strong></p><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p><p><strong>用于构造方法中</strong></p><p>this出现在构造方法中，代表构造方法正在初始化的那个对象。</p><h3 id="14-static关键字"><a class="markdownIt-Anchor" href="#14-static关键字"></a> 1.4 static关键字</h3><p>所以Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><p><strong>定义格式和使用</strong></p><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用 类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 数据类型 变量名 = 初始值；    <br></code></pre></td></tr></table></figure><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// 传智播客</span><br>    Student.schoolName = <span class="hljs-string">&quot;黑马程序员&quot;</span>;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// 黑马程序员</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例变量及其访问</strong></p><p>无static修饰的成员变量属于每个对象的， 这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例成员变量</strong></p><p><strong>静态方法及其访问</strong></p><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者静态方法</strong>。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>实例方法及其访问</strong></p><p>无static修饰的成员方法属于每个对象的，这个成员方法也叫做<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例方法</strong></p><p><strong>小结</strong></p><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><h2 id="2-继承"><a class="markdownIt-Anchor" href="#2-继承"></a> 2 继承</h2><h3 id="21-继承的含义"><a class="markdownIt-Anchor" href="#21-继承的含义"></a> 2.1 继承的含义</h3><p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：</p><p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass）<strong>或者</strong>基类</strong>。</p><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="22-继承的好处"><a class="markdownIt-Anchor" href="#22-继承的好处"></a> 2.2 继承的好处</h3><ol><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li></ol><h3 id="23-继承的格式"><a class="markdownIt-Anchor" href="#23-继承的格式"></a> 2.3 继承的格式</h3><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>	...<br>&#125;<br><br>class 子类 extends 父类 &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p><p>1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><p>2.子类继承父类，就可以直接得到父类的成员变量和方法。</p><h3 id="24-继承后的特点"><a class="markdownIt-Anchor" href="#24-继承后的特点"></a> *2.4 继承后的特点</h3><p>并不是父类的所有内容都可以给子类继承的：</p><p><strong>子类不能继承父类的构造方法。</strong></p><p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p><p><strong>1.成员变量</strong></p><p>当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？</p><ol><li><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</p></li><li><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。</p></li><li><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p></li></ol><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p><p><strong>2.成员方法</strong></p><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><ol><li><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p></li><li><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p></li></ol><p>这里记住一个重要的概念：<strong>虚方法表</strong></p><p><strong>3.构造方法</strong></p><p><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法</strong></p><ul><li>子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。</li><li>子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。</li></ul><h3 id="25-方法重写"><a class="markdownIt-Anchor" href="#25-方法重写"></a> 2.5 方法重写</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p><p>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p><h3 id="26-override重写注解"><a class="markdownIt-Anchor" href="#26-override重写注解"></a> 2.6 @Override重写注解</h3><ul><li><p>@Override:注解，重写注解校验！</p></li><li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p></li><li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p></li></ul><p><strong>注意事项</strong></p><ol><li>方法重写是发生在子父类之间的关系。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h3 id="27-super案例图解"><a class="markdownIt-Anchor" href="#27-super案例图解"></a> 2.7 super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造调用时，一定先调用父类的构造方法。理解图解如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232059169.jpg" srcset="/img/loading.gif" lazyload alt></p><h3 id="28-小结"><a class="markdownIt-Anchor" href="#28-小结"></a> 2.8 小结</h3><ul><li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p></li><li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p></li><li><p><strong>super(…)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></p></li><li><p>super(…)可以调用父类构造方法初始化继承自父类的成员变量的数据。</p></li><li><p>this(…)可以调用本类中的其他构造方法。</p></li></ul><h2 id="3-多态"><a class="markdownIt-Anchor" href="#3-多态"></a> 3 多态</h2><h3 id="31-多态的形式"><a class="markdownIt-Anchor" href="#31-多态的形式"></a> 3.1 多态的形式</h3><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类/实现类构造器;<br>变量名.方法名();<br></code></pre></td></tr></table></figure><p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><h3 id="32-多态的使用场景"><a class="markdownIt-Anchor" href="#32-多态的使用场景"></a> *3.2 多态的使用场景</h3><p>如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232104032.png" srcset="/img/loading.gif" lazyload alt="多态的应用场景"></p><p>有了多态之后，方法的形参就可以定义为共同的父类Person。</p><p><strong>要注意的是：</strong></p><ul><li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li><li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。</li><li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li></ul><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202404232104921.png" srcset="/img/loading.gif" lazyload alt="多态的应用场景"></p><h3 id="33-多态的定义和前提"><a class="markdownIt-Anchor" href="#33-多态的定义和前提"></a> *3.3 多态的定义和前提</h3><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p><p><strong>前提【重点】</strong></p><ol><li><p>有继承或者实现关系</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h3 id="34-多态的运行特点"><a class="markdownIt-Anchor" href="#34-多态的运行特点"></a> *3.4 多态的运行特点</h3><p>调用成员变量时：编译看左边，运行看左边</p><p>调用成员方法时：编译看左边，运行看右边</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Fu</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>()；<br><span class="hljs-comment">//编译看左边的父类中有没有name这个属性，没有就报错</span><br><span class="hljs-comment">//在实际运行的时候，把父类name属性的值打印出来</span><br>System.out.println(f.name);<br><span class="hljs-comment">//编译看左边的父类中有没有show这个方法，没有就报错</span><br><span class="hljs-comment">//在实际运行的时候，运行的是子类中的show方法</span><br>f.show();<br></code></pre></td></tr></table></figure><p><strong>多态的弊端</strong></p><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><h3 id="35-引用类型转换"><a class="markdownIt-Anchor" href="#35-引用类型转换"></a> 3.5 引用类型转换</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&quot;小麻烦&quot;。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5;</li><li>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14</li></ul><p>多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p><ul><li><p><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。</p></li><li><p><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p></li></ul><h3 id="36-instanceof关键字"><a class="markdownIt-Anchor" href="#36-instanceof关键字"></a> *3.6 instanceof关键字</h3><p>为了避免类型转换异常ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名 <span class="hljs-keyword">instanceof</span> 数据类型 <br>如果变量属于该数据类型或者其子类类型，返回<span class="hljs-literal">true</span>。<br>如果变量不属于该数据类型或者其子类类型，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>所以，转换前，我们最好先做一个判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;       <br>            c.catchMouse();        <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;       <br>            d.watchHouse();       <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>instanceof新特性</strong></p><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新特性</span><br><span class="hljs-comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span><br><span class="hljs-comment">//如果不是，则不强转，结果直接是false</span><br><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d)&#123;<br>    d.lookHome();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>    c.catchMouse();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;没有这个类型，无法转换&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-权限修饰符"><a class="markdownIt-Anchor" href="#4-权限修饰符"></a> 4 权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。</p><ul><li><p>public：公共的，所有地方都可以访问。</p></li><li><p>protected：本类 ，本包，其他包中的子类都可以访问。</p></li><li><p>默认（没有修饰符）：本类 ，本包可以访问。</p><p>注意：默认是空着不写，不是default</p></li><li><p>private：私有的，当前类可以访问。<br><code>public &gt; protected &gt; 默认 &gt; private</code></p></li></ul><p><strong>不同权限的访问能力</strong></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code>public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，就是默认权限</p></blockquote><h2 id="5-final关键字"><a class="markdownIt-Anchor" href="#5-final关键字"></a> 5 final关键字</h2><h3 id="51-基本概念"><a class="markdownIt-Anchor" href="#51-基本概念"></a> 5.1 基本概念</h3><p>Java提供了<code>final</code> 关键字，表示修饰的内容不可变。</p><ul><li><strong>final</strong>： 不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h3 id="52-使用方式"><a class="markdownIt-Anchor" href="#52-使用方式"></a> 5.2 使用方式</h3><p><strong>1.修饰类</strong></p><p>final修饰的类，不能被继承。</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class 类名 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p><p><strong>2.修饰方法</strong></p><p>final修饰的方法，不能被重写。<br>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.修饰变量</strong></p><p><strong>局部变量</strong>：基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。</p><p><strong>成员变量</strong>：成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。</p><p><strong>注意：每个构造方法中都要赋值一次！</strong></p></li></ul><blockquote><p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p></blockquote></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>2024.2.7 Java基础</div><div>https://fulequn.github.io/2024/02/Article202402071/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年2月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/02/Article202402101/" title="2024.2.10 面经+Java基础"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">2024.2.10 面经+Java基础</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/02/Article202402051/" title="2024.2.5 Java基础"><span class="hidden-mobile">2024.2.5 Java基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>