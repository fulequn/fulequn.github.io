<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="6.2 二分查找  前言 二分查找的思想非常简单，在有序的数据中每次按照中点进行尝试，如果中间点大于我们要查找的值，则答案应该位于左侧， 反之右侧。由于每次可以排除现有数据量的一半，因此时间复杂度是O(logn)O(logn)O(logn)。 以下我们提供两套二分查找的模板。两个模板的原理都是一样的，区别在于边界的处理。二分查找的难点往往也在于边界。因此如果我们划分的边界是[l,mid]和[mi"><meta property="og:type" content="article"><meta property="og:title" content="算法训练-6高效算法部分 二分查找"><meta property="og:url" content="https://fulequn.github.io/2024/05/Article202405051/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="6.2 二分查找  前言 二分查找的思想非常简单，在有序的数据中每次按照中点进行尝试，如果中间点大于我们要查找的值，则答案应该位于左侧， 反之右侧。由于每次可以排除现有数据量的一半，因此时间复杂度是O(logn)O(logn)O(logn)。 以下我们提供两套二分查找的模板。两个模板的原理都是一样的，区别在于边界的处理。二分查找的难点往往也在于边界。因此如果我们划分的边界是[l,mid]和[mi"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-05-05T02:38:58.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:08.086Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><title>算法训练-6高效算法部分 二分查找 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法训练-6高效算法部分 二分查找"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-05-05 10:38" pubdate>2024年5月5日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>6.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>51 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">算法训练-6高效算法部分 二分查找</h1><div class="markdown-body"><h1 id="62-二分查找"><a class="markdownIt-Anchor" href="#62-二分查找"></a> 6.2 二分查找</h1><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>二分查找的思想非常简单，在有序的数据中每次按照中点进行尝试，如果中间点大于我们要查找的值，则答案应该位于左侧， 反之右侧。由于每次可以排除现有数据量的一半，因此时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>以下我们提供两套二分查找的模板。两个模板的原理都是一样的，区别在于边界的处理。二分查找的难点往往也在于边界。因此如果我们划分的边界是[l,mid]和[mid + 1, r]那我们选择模板1。如果我们划分的边界是[0,mid-1]和[mid,r] 那我们选择模板2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">bsec1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bsec2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ( l + r + <span class="hljs-number">1</span> ) /<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>找到恰好等于目标值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) rt = mid;<br>    <span class="hljs-keyword">else</span> lf = mid + <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> nums[rt] == target ? rt : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>找到第一个大于等于目标值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (lf &lt;= rt) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (cur == target) <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt; target) rt = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> lf = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> lf;<br></code></pre></td></tr></table></figure><ul><li>找到第一个大于目标值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((lf - rt) &gt;&gt; <span class="hljs-number">1</span>) + rt;<br>    <span class="hljs-keyword">if</span> (cur &gt; target) rt = mid;<br>    <span class="hljs-keyword">else</span> lf = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> rt;<br></code></pre></td></tr></table></figure><ul><li>找到小于等于目标值的最大值【最小值最大】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = x;<br><span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) rt = mid;<br>    <span class="hljs-keyword">else</span> lf = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> rt;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">二分查找</a></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">9 出现在 nums 中并且下标为 4</span><br><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">-1</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2 不存在 nums 中因此返回 -1</span><br><br>提示：<br>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>由于数组是有序的，因此可以使用二分进行查找。</p><p>假设说 <code>nums[mid] &gt;= target</code> ，则说明此时应该在 <code>[lf, mid]</code> 中寻找答案，那么<code>r = mid</code>；因此我们套用模板二即可。</p><p>当然如果不存在应该返回-1。</p><p><strong>代码解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// search 方法用于在升序数组 nums 中查找目标值 target</span><br>    <span class="hljs-comment">// 如果找到目标值，则返回其索引；如果未找到，则返回 -1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 lf 和 rt，分别指向数组的起始位置和结束位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果中间位置的元素大于等于目标值，则在左半部分继续查找</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                rt = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，在右半部分继续查找</span><br>                lf = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在退出循环时，如果右指针所指向的元素等于目标值，则返回其索引 rt</span><br>        <span class="hljs-comment">// 如果不等于目标值，说明未找到目标值，返回 -1</span><br>        <span class="hljs-keyword">return</span> nums[rt] == target ? rt : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x-的平方根"><a class="markdownIt-Anchor" href="#x-的平方根"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">x 的平方根</a></h3><p>给你一个非负整数 x ，计算并返回 x 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去</strong> 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">示例 <span class="hljs-number">1</span>：<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">8</span> 的算术平方根是 <span class="hljs-number">2.82842</span>…<span class="hljs-punctuation">,</span> 由于返回类型是整数，小数部分将被舍去。<br><br>提示：<br><span class="hljs-number">0</span> &lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>由于不能使用库函数，因此我们需要“对答案进行二分”。</p><p>答案可能的范围是 [0, x]，因此我们要二分的思路枚举这个区间。</p><p>但是要舍去小数的部分，换个说法就是找到区间 [0, x] 中小于等于x的最大值。</p><p>最小值最大的问题也是二分的一个经典标志。</p><p>如果 <code>mid^2</code> 大于等于 x，则说明此时应该在 <code>[l, mid]</code> 之间找答案，反之则是 <code>[mid + 1, r]</code> 。因此套用模板2即可。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// mySqrt 方法用于计算并返回整数 x 的平方根</span><br>    <span class="hljs-comment">// 使用二分查找算法在 [0, x] 的范围内查找最接近 x 的平方数的整数次方</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 lf 和 rt，分别指向搜索范围的起始点和结束点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = x;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 计算中间值的平方，使用 long 类型避免在计算大数时溢出</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) mid * mid;<br>            <span class="hljs-comment">// 如果中间值的平方大于等于目标数 x，则在左半部分继续查找</span><br>            <span class="hljs-keyword">if</span> (cur &gt;= x) &#123;<br>                rt = mid; <span class="hljs-comment">// 更新右指针</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果小于目标数，则在右半部分继续查找</span><br>                lf = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新左指针</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在退出循环时，检查右指针所指向的数的平方是否正好等于目标数 x</span><br>        <span class="hljs-comment">// 如果是，则返回右指针的值，即 x 的平方根</span><br>        <span class="hljs-comment">// 如果不是，返回右指针的值减 1，因为在二分查找中，已经确保了该值的平方小于 x 且是小于等于 x 的所有平方数中最大的</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)rt * rt == x ? rt : rt - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索插入位置"><a class="markdownIt-Anchor" href="#搜索插入位置"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的算法。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 5</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 2</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><br><span class="hljs-attribute">示例 3</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 7</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4</span><br><br><span class="hljs-attribute">提示</span><span class="hljs-punctuation">:</span><br>1 &lt;= nums.length &lt;= 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 为 无重复元素 的 升序 排列数组<br>-10^4 &lt;= target &lt;= 10^4<br></code></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>等价于找到大于等于 <code>target</code> 的最小值的下标</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// searchInsert 方法用于在一个升序数组 nums 中找到目标值 target 的插入位置</span><br>    <span class="hljs-comment">// 即使目标值在数组中不存在，该方法也能找到其合适的插入位置，以保持数组的有序性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左指针 lf 和右指针 rt，分别指向数组的开始和结束</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = nums.length;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (lf &lt; rt) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lf + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果中间位置的元素大于等于目标值，则在左半部分继续查找</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                rt = mid; <span class="hljs-comment">// 更新右指针为 mid，因为 target 应该在 [lf, mid] 范围内</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果中间位置的元素小于目标值，则在右半部分继续查找</span><br>                lf = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新左指针为 mid + 1，因为 target 应该在 [mid + 1, rt) 范围内</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在退出循环时，左指针和右指针相遇，即 lf == rt</span><br>        <span class="hljs-comment">// 此时，rt 指向的位置就是目标值 target 应该插入的位置</span><br>        <span class="hljs-comment">// 如果目标值在数组中已存在，则 rt 指向的就是目标值的位置</span><br>        <span class="hljs-comment">// 如果目标值不在数组中，则 rt 指向的就是目标值应该插入的第一个大于或等于 target 的位置</span><br>        <span class="hljs-keyword">return</span> rt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第一个错误的版本"><a class="markdownIt-Anchor" href="#第一个错误的版本"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/">第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>：<br>输入：n = <span class="hljs-number">5</span>, bad = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-literal">false</span><br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span> -&gt;</span> <span class="hljs-literal">true</span><br>调用 isBadVersion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>)</span> -&gt;</span> <span class="hljs-literal">true</span><br>所以，<span class="hljs-number">4</span> 是第一个错误的版本。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：n = <span class="hljs-number">1</span>, bad = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br><br>提示：<br><span class="hljs-number">1</span> &lt;= bad &lt;= n &lt;= <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VersionControl</span> &#123;<br><br>    <span class="hljs-comment">// firstBadVersion 方法用于找出第一个错误版本的编号</span><br>    <span class="hljs-comment">// 假设有一个版本控制系统，版本编号从 1 到 n，其中第 i 个版本是 badVersion 函数的一个调用</span><br>    <span class="hljs-comment">// 该方法使用二分查找算法来确定第一个错误版本的编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，分别指向可能的第一个错误版本的最小和最大编号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = n;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-comment">// 由于 l 和 r 相减可能会溢出，所以先进行减法操作，再右移一位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((l - r) &gt;&gt; <span class="hljs-number">1</span>) + r;<br>            <span class="hljs-comment">// 调用 isBadVersion 方法检查 mid 是否是错误版本</span><br>            <span class="hljs-comment">// 如果是错误版本，则第一个错误版本必定在 [l, mid] 范围内，因此将 r 更新为 mid</span><br>            <span class="hljs-keyword">if</span> (isBadVersion(mid)) &#123;<br>                r = mid;<br>            &#125;<br>            <span class="hljs-comment">// 如果 mid 不是错误版本，则第一个错误版本必定在 [mid + 1, r] 范围内，因此将 l 更新为 mid + 1</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在退出循环时，左指针和右指针相遇，即 l == r</span><br>        <span class="hljs-comment">// 此时，l（或 r）指向的就是第一个错误版本的编号</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找峰值"><a class="markdownIt-Anchor" href="#寻找峰值"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a></h3><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(logn)</code> 的算法来解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span><br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br><br>提示：<br><span class="hljs-number">1</span> &lt;= nums.length &lt;= <span class="hljs-number">1000</span><br>- <span class="hljs-number">2</span>^<span class="hljs-number">31</span> &lt;= nums[i] &lt;= <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>对于所有有效的 i 都有 nums[i] != nums[i + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// findPeakElement 方法用于找出一个数组中的峰值元素</span><br>    <span class="hljs-comment">// 数组中峰值的定义是：元素的值大于它的左右相邻元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，分别指向数组的起始位置和结束位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引 mid，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免在计算中发生溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((l - r) &gt;&gt; <span class="hljs-number">1</span>) + r;<br>            <span class="hljs-comment">// 比较中间元素与其右侧相邻元素的值</span><br>            <span class="hljs-comment">// 如果 mid 位置的元素小于其右侧相邻元素，则峰值一定在 mid + 1 的右侧，更新左指针为 mid + 1</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则，峰值一定在 mid 或者 mid 的左侧，更新右指针为 mid</span><br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当左指针 l 与右指针 r 相遇时，循环结束</span><br>        <span class="hljs-comment">// 此时 l（或 r）即为数组中的峰值元素的索引，直接返回</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="爱吃香蕉的珂珂"><a class="markdownIt-Anchor" href="#爱吃香蕉的珂珂"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/koko-eating-bananas/">爱吃香蕉的珂珂</a></h3><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">示例 <span class="hljs-number">1</span>：<br>输入：piles = <span class="hljs-selector-attr">[3,6,7,11]</span>, h = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">4</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：piles = <span class="hljs-selector-attr">[30,11,23,4,20]</span>, h = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">30</span><br><br>示例 <span class="hljs-number">3</span>：<br>输入：piles = <span class="hljs-selector-attr">[30,11,23,4,20]</span>, h = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">23</span><br><br>提示：<br><span class="hljs-number">1</span> &lt;= piles<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>piles<span class="hljs-selector-class">.length</span> &lt;= h &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-number">1</span> &lt;= piles<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// minEatingSpeed 方法用于计算在 h 小时内吃完所有香蕉的最小速度</span><br>    <span class="hljs-comment">// piles 数组表示各个香蕉堆的数量，h 表示分配香蕉的小时数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-comment">// 计算所有香蕉的总数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles) &#123;<br>            sum += pile;<br>        &#125;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，分别表示吃香蕉速度的最小值和最大值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = sum;<br>        <span class="hljs-comment">// 使用二分查找算法来确定最小吃香蕉的速度</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间速度</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((l - r) &gt;&gt; <span class="hljs-number">1</span>) + r;<br>            <span class="hljs-comment">// 使用 check 方法检查当前速度 mid 是否能在 h 小时内吃完所有糖果</span><br>            <span class="hljs-keyword">if</span> (check(mid, piles, h)) &#123;<br>                r = mid; <span class="hljs-comment">// 如果可以，那么最小速度可能在 [l, mid] 范围内，更新右指针</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果不可以，最小速度可能在 [mid + 1, r] 范围内，更新左指针</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当 l 和 r 相遇时，循环结束，此时 r 即为所求的最小吃香蕉速度，返回 r 的整数值</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)r;<br>    &#125;<br><br>    <span class="hljs-comment">// check 方法用于检查给定的吃香蕉速度 x 是否能在 h 小时内吃完所有香蕉</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化所需小时数</span><br>        <span class="hljs-comment">// 遍历所有香蕉堆，计算以速度 x 吃完它们所需的小时数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles) &#123;<br>            <span class="hljs-comment">// 如果香蕉堆的数量能被速度 x 整除，则所需小时数为香蕉数量除以速度</span><br>            <span class="hljs-keyword">if</span> (pile % x == <span class="hljs-number">0</span>) &#123;<br>                cnt += pile / x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果不能整除，需要额外加一小时来吃完剩余的香蕉</span><br>                cnt += (pile / x) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果所需小时数小于等于 h，则返回 true，表示速度 x 可行</span><br>        <span class="hljs-keyword">return</span> cnt &lt;= h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有效的完全平方数"><a class="markdownIt-Anchor" href="#有效的完全平方数"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/">有效的完全平方数</a></h3><p>给定一个 正整数 <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code>，否则返回 <code>false</code> 。</p><p><strong>完全平方数</strong> 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p><p>进阶：不要 使用任何内置的库函数，如  <code>sqrt</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">示例 <span class="hljs-number">1</span>：<br>输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">16</span><br>输出：<span class="hljs-keyword">true</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">14</span><br>输出：<span class="hljs-keyword">false</span><br><br>提示：<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">num</span> &lt;= <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>由于不能使用库函数，因此我们需要对答案进行二分。</p><p>初始的二分区间可以定义为[0, num]。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// isPerfectSquare 方法用于判断给定的整数 num 是否为一个完全平方数</span><br>    <span class="hljs-comment">// 一个完全平方数是一个整数，它可以表示为另一个整数的平方</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，l 从 0 开始，r 从 num 开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = num;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引 mid，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((l - r) &gt;&gt; <span class="hljs-number">1</span>) + r;<br>            <span class="hljs-comment">// 检查 mid 的平方是否大于等于 num</span><br>            <span class="hljs-comment">// 如果是，说明可能的完全平方根在 [l, mid] 范围内，更新右指针为 mid</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)mid * mid &gt;= num) &#123;<br>                r = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果不是，说明可能的完全平方根在 [mid + 1, r] 范围内，更新左指针为 mid + 1</span><br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在退出循环时，左指针和右指针相遇，即 l == r</span><br>        <span class="hljs-comment">// 此时，r 指向的值是 num 的可能的完全平方根</span><br>        <span class="hljs-comment">// 检查 r 的平方是否等于 num，若是，则 num 是完全平方数，返回 true</span><br>        <span class="hljs-comment">// 否则，num 不是完全平方数，返回 false</span><br>        <span class="hljs-keyword">return</span> r * r == num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找比目标字母大的最小字母"><a class="markdownIt-Anchor" href="#寻找比目标字母大的最小字母"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h3><p>给你一个排序（<strong>非递减顺序</strong>）后的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。如果不存在这样的字符，则返回 <code>letters</code> 的第一个字符。</p><p>在比较时，字母是依序循环出现的。举个例子：</p><p>如果目标字母 <code>target = ‘z’</code> 并且字符列表为 <code>letters = [‘a’, ‘b’]</code>，则答案返回 ‘a’</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs r">示例 <span class="hljs-number">1</span>：<br>输入<span class="hljs-operator">:</span> <span class="hljs-built_in">letters</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">[</span>“<span class="hljs-built_in">c</span>”<span class="hljs-punctuation">,</span> “f”<span class="hljs-punctuation">,</span> “j”<span class="hljs-punctuation">]</span>，target <span class="hljs-operator">=</span> “a”<br>输出<span class="hljs-operator">:</span> “<span class="hljs-built_in">c</span>”<br><br>示例 <span class="hljs-number">2</span><span class="hljs-operator">:</span><br>输入<span class="hljs-operator">:</span> <span class="hljs-built_in">letters</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">[</span>“<span class="hljs-built_in">c</span>”<span class="hljs-punctuation">,</span>“f”<span class="hljs-punctuation">,</span>“j”<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> target <span class="hljs-operator">=</span> “<span class="hljs-built_in">c</span>”<br>输出<span class="hljs-operator">:</span> “f”<br><br>示例 <span class="hljs-number">3</span><span class="hljs-operator">:</span><br>输入<span class="hljs-operator">:</span> <span class="hljs-built_in">letters</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">[</span>“<span class="hljs-built_in">c</span>”<span class="hljs-punctuation">,</span>“f”<span class="hljs-punctuation">,</span>“j”<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> target <span class="hljs-operator">=</span> “d”<br>输出<span class="hljs-operator">:</span> “f”<br><br>提示：<br><span class="hljs-number">2</span> <span class="hljs-operator">&lt;=</span> letters.length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-number">4</span><br><span class="hljs-built_in">letters</span><span class="hljs-punctuation">[</span>i<span class="hljs-punctuation">]</span> 是一个小写字母<br><span class="hljs-built_in">letters</span> 按非递减顺序排序<br><span class="hljs-built_in">letters</span> 最少包含两个不同的字母<br>target 是一个小写字母<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>此题转换为：找到数组中第一个大于target的字符。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// nextGreatestLetter 方法用于在字符数组 letters 中找出第一个大于目标字符 target 的字符</span><br>    <span class="hljs-comment">// 如果所有字符都小于等于 target，则返回数组的第一个字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">nextGreatestLetter</span><span class="hljs-params">(<span class="hljs-type">char</span>[] letters, <span class="hljs-type">char</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，分别指向数组的起始位置和末尾位置（不包括末尾）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = letters.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 使用 while 循环进行二分查找，当左指针小于右指针时继续查找</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间位置的索引 mid，使用无符号右移操作符 &quot;&gt;&gt;&quot; 避免溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 比较中间字符 letters[mid] 与目标字符 target</span><br>            <span class="hljs-comment">// 如果 letters[mid] 大于 target，则说明大于 target 的字符可能在 [l, mid] 范围内，更新右指针 r 为 mid</span><br>            <span class="hljs-keyword">if</span> (letters[mid] &gt; target) &#123;<br>                r = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果 letters[mid] 小于或等于 target，则说明大于 target 的字符可能在 [mid+1, r] 范围内（包括 mid），更新左指针 l 为 mid + 1</span><br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束后，右指针 r 指向的位置可能是大于 target 的最小字符，但也可能是 target 本身或小于 target 的字符</span><br>        <span class="hljs-comment">// 因此需要检查 letters[r] 是否大于 target</span><br>        <span class="hljs-comment">// 如果大于，则返回 letters[r]，因为它是大于 target 的最小字符</span><br>        <span class="hljs-keyword">if</span> (letters[r] &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> letters[r];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 letters[r] 不大于 target，说明所有字符都小于等于 target，或者大于 target 的字符不在 [l, r] 范围内</span><br>            <span class="hljs-comment">// 根据题意，这种情况下返回数组的第一个字符 letters[0]</span><br>            <span class="hljs-keyword">return</span> letters[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">示例 <span class="hljs-number">1</span>：<br>输入：nums = <span class="hljs-selector-attr">[5,7,7,8,8,10]</span>, target = <span class="hljs-number">8</span><br>输出：<span class="hljs-selector-attr">[3,4]</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = <span class="hljs-selector-attr">[5,7,7,8,8,10]</span>, target = <span class="hljs-number">6</span><br>输出：<span class="hljs-selector-attr">[-1,-1]</span><br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = <span class="hljs-selector-attr">[]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-selector-attr">[-1,-1]</span><br><br>提示：<br><span class="hljs-number">0</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br>- <span class="hljs-number">10</span>^<span class="hljs-number">9</span> &lt;= nums<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br>nums 是一个非递减数组<br>- <span class="hljs-number">10</span>^<span class="hljs-number">9</span> &lt;= target &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// searchRange 方法用于找出给定数组 nums 中目标值 target 的第一个和最后一个索引</span><br>    <span class="hljs-comment">// 如果目标值不在数组中，则返回 &#123;-1, -1&#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 如果数组为空，直接返回 &#123;-1, -1&#125;</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <br>        <span class="hljs-comment">// 第一部分：找到第一个等于 target 的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间索引 mid，使用无符号右移操作防止溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 根据 nums[mid] 与 target 的大小关系调整左右指针</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid; <span class="hljs-comment">// target 在左半边</span><br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右半边</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果 r 指针所指向的元素不等于 target，说明 target 不在数组中，返回 &#123;-1, -1&#125;</span><br>        <span class="hljs-keyword">if</span> (nums[r] != target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <br>        <span class="hljs-comment">// 保存第一个等于 target 的元素的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> r;<br>        <br>        <span class="hljs-comment">// 重置左右指针，寻找最后一个等于 target 的值</span><br>        l = <span class="hljs-number">0</span>;<br>        r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间索引 mid，这里使用 (l + r + 1) 确保 mid 偏向右半边</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 根据 nums[mid] 与 target 的大小关系调整左右指针</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左半边</span><br>            <span class="hljs-keyword">else</span> l = mid; <span class="hljs-comment">// target 在右半边或等于 mid</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回第一个和最后一个等于 target 的元素的索引</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;first, r&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割数组的最大值"><a class="markdownIt-Anchor" href="#分割数组的最大值"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值</a></h3><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p><p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">示例 <span class="hljs-number">1</span>：<br>输入：nums = <span class="hljs-selector-attr">[7,2,5,10,8]</span>, m = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">18</span><br>解释：<br>一共有四种方法将 nums 分割为 <span class="hljs-number">2</span> 个子数组。<br>其中最好的方式是将其分为 <span class="hljs-selector-attr">[7,2,5]</span> 和 <span class="hljs-selector-attr">[10,8]</span> 。<br>因为此时这两个子数组各自的和的最大值为<span class="hljs-number">18</span>，在所有情况中最小。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, m = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">9</span><br><br>示例 <span class="hljs-number">3</span>：<br>输入：nums = <span class="hljs-selector-attr">[1,4,4]</span>, m = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br><br>提示：<br><span class="hljs-number">1</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">1000</span><br><span class="hljs-number">0</span> &lt;= nums<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br><span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-number">50</span>, nums.length)<br></code></pre></td></tr></table></figure><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// splitArray 方法用于找出数组 nums 可以被分割为 m 部分的最小总和</span><br>    <span class="hljs-comment">// 其中每部分的总和不超过 x，返回满足条件的最小 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-comment">// 计算数组 nums 的总和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-comment">// 初始化左右指针 l 和 r，分别表示最小总和和最大总和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = sum;<br>        <span class="hljs-comment">// 使用二分查找算法在 [l, r] 范围内查找满足条件的最小 x</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-comment">// 计算中间值 mid</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 使用 check 方法检查当前的 mid 是否满足条件</span><br>            <span class="hljs-keyword">if</span> (check(mid, nums, m)) &#123;<br>                r = mid; <span class="hljs-comment">// 如果满足条件，更新右指针为 mid，因为可能存在更小的值</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果不满足条件，更新左指针为 mid + 1，因为需要更大的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回找到的最小总和 x</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">// check 方法用于检查是否存在一个 x 值，使得数组 nums 可以被分割为 m 部分，每部分的总和不超过 x</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化分割的部分数量为 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化当前部分的总和为 0</span><br>        <span class="hljs-comment">// 遍历数组 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前元素加上当前部分的总和不超过 x，则将其加入当前部分</span><br>            <span class="hljs-keyword">if</span> (cur + nums[i] &lt;= x) &#123;<br>                cur += nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前元素大于 x，则无法分割，返回 false</span><br>                <span class="hljs-keyword">if</span> (nums[i] &gt; x) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">// 否则，开始新的部分，更新当前部分的总和为当前元素的值，并增加分割的部分数量</span><br>                cur = nums[i];<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回分割的部分数量是否不超过 m</span><br>        <span class="hljs-keyword">return</span> cnt &lt;= m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>算法训练-6高效算法部分 二分查找</div><div>https://fulequn.github.io/2024/05/Article202405051/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年5月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/05/Article202405061/" title="算法训练-6高效算法部分 贪心算法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法训练-6高效算法部分 贪心算法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/05/Article202405041/" title="算法训练-6高效算法部分 滑动窗口"><span class="hidden-mobile">算法训练-6高效算法部分 滑动窗口</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>