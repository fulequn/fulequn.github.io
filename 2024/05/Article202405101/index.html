<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="前言 记忆化搜索其实就是在递归的基础上记录已经算过的状态，下次如果运算过相同的状态后，直接返回已经算过的状态，避免重复运算。 这种算法在笔试过程中是非常好用的一个算法，能够解决非常多的问题，特别是一些比较复杂的动态规划，用记忆化搜索可以很快且很形象的解决问题。  打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗"><meta property="og:type" content="article"><meta property="og:title" content="算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分"><meta property="og:url" content="https://fulequn.github.io/2024/05/Article202405101/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="前言 记忆化搜索其实就是在递归的基础上记录已经算过的状态，下次如果运算过相同的状态后，直接返回已经算过的状态，避免重复运算。 这种算法在笔试过程中是非常好用的一个算法，能够解决非常多的问题，特别是一些比较复杂的动态规划，用记忆化搜索可以很快且很形象的解决问题。  打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329776.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329281.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329952.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329654.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330833.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330588.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330416.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102331236.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102331305.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333149.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333734.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333071.png"><meta property="article:published_time" content="2024-05-10T15:03:31.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:08.117Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329776.png"><title>算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分 - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-05-10 23:03" pubdate>2024年5月10日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>8.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>68 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分</h1><div class="markdown-body"><hr><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>记忆化搜索其实就是在递归的基础上记录已经算过的状态，下次如果运算过相同的状态后，直接返回已经算过的状态，避免重复运算。</p><p>这种算法在笔试过程中是非常好用的一个算法，能够解决非常多的问题，特别是一些比较复杂的动态规划，用记忆化搜索可以很快且很形象的解决问题。</p><h3 id="打家劫舍"><a class="markdownIt-Anchor" href="#打家劫舍"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">示例 1：<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br><br>示例 2：<br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br><br>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>我们从头开始考虑每一家，每一家都有两种选择，要么偷，要么不偷，在两条不同的递归路径中选取最大的即可。式子如下</p><blockquote><p>f(i) = max(f(i + 1), f(i + 2) + nums[i])</p></blockquote><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// rob 方法用于计算打劫一个数组中所有房屋的最大总金额</span><br>    <span class="hljs-comment">// 问题约束是不能连续打劫相邻的房屋</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化动态规划数组 dp，其长度与输入数组 nums 相同</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 使用 Arrays.fill 方法将 dp 数组的所有元素初始化为 -1，表示未计算过</span><br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 调用 dfs 方法从索引 0 开始进行递归计算</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums);<br>    &#125;<br><br>    <span class="hljs-comment">// dp 数组用于存储动态规划的中间结果</span><br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于计算从索引 index 开始打劫 nums 数组的最大总金额</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果索引 index 超出数组 nums 的长度，说明无法再打劫，返回 0</span><br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 dp 数组在当前索引 index 已经有值，直接返回该值，避免重复计算</span><br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> dp[index];<br>        &#125;<br>        <span class="hljs-comment">// 否则，计算两种选择的金额：跳过当前房屋和打劫当前房屋</span><br>        <span class="hljs-comment">// 打劫当前房屋的金额是当前房屋金额加上跳过下一个房屋后的金额（即从 index + 2 开始的金额）</span><br>        <span class="hljs-comment">// 比较这两种选择，取较大值作为结果，并存储在 dp 数组中</span><br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(index + <span class="hljs-number">1</span>, nums), dfs(index + <span class="hljs-number">2</span>, nums) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(nums): <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(i+<span class="hljs-number">1</span>), dfs(i+<span class="hljs-number">2</span>) + nums[i])<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-ii"><a class="markdownIt-Anchor" href="#打家劫舍-ii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，<strong>相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">示例 1：<br>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br><br>示例 2：<br>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。<br>偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br><br>示例 3：<br>输入：nums = [1,2,3]<br>输出：3<br><br>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 1000<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p>此题与”打家劫舍”基本一致，一个技巧就是我们应该分两段来考虑，一段是[0, nums.length - 2] 另一端是 [1, nums.length - 1]。分别对这两段进行“打家劫舍”的操作然后取最大值即可得出正确答案。</p><p>当然这里不需要重新建立数组，我们只需要在递归的时候标记起点和终点即可。值得注意的一点是mem数组在两次递归的时候需要重新 初始化。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 动态规划解决打家劫舍问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果只有一间房屋，则直接返回该房屋的金额</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 初始化备忘录数组</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 将备忘录数组所有元素初始化为-1，表示未计算过</span><br>        Arrays.fill(mem, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 计算从第一间房屋到倒数第二间房屋的最大金额</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-comment">// 清空备忘录数组，重新初始化为-1</span><br>        Arrays.fill(mem, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 计算从第二间房屋到最后一间房屋的最大金额</span><br>        ans = Math.max(ans, dfs(<span class="hljs-number">1</span>, nums.length, nums));<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 备忘录数组，记录每个房屋到最后一间房屋的最大金额</span><br>    <span class="hljs-type">int</span>[] mem;<br>    <br>    <span class="hljs-comment">// 递归函数，计算从第idx间房屋到第end间房屋的最大金额</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果房屋索引超过或等于end，返回0</span><br>        <span class="hljs-keyword">if</span> (idx &gt;= end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过该索引位置的最大金额，则直接返回备忘录中的结果</span><br>        <span class="hljs-keyword">if</span> (mem[idx] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> mem[idx];<br>        <br>        <span class="hljs-comment">// 计算当前房屋偷窃和不偷窃两种情况下的最大金额，并取其中较大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Math.max(dfs(idx + <span class="hljs-number">1</span>, end, nums), dfs(idx + <span class="hljs-number">2</span>, end, nums) + nums[idx]);<br>        <span class="hljs-comment">// 将计算得到的最大金额存入备忘录数组中</span><br>        mem[idx] = ans;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, nums, dp</span>):<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(nums): <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dp: <span class="hljs-keyword">return</span> dp[i]<br>            dp[i] = <span class="hljs-built_in">max</span>(dfs(i+<span class="hljs-number">1</span>,nums,dp), dfs(i+<span class="hljs-number">2</span>,nums, dp) + nums[i])<br>            <span class="hljs-keyword">return</span> dp[i]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(<span class="hljs-number">0</span>, nums[<span class="hljs-number">1</span>:], &#123;&#125;), dfs(<span class="hljs-number">0</span>, nums[:-<span class="hljs-number">1</span>], &#123;&#125;))<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-iii"><a class="markdownIt-Anchor" href="#打家劫舍-iii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 III</a></h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p>示例 1:</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329776.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入: root = [3,2,3,null,3,null,1]<br>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p></blockquote><p>示例 2:</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329281.png" srcset="/img/loading.gif" lazyload alt="示例2"></p><blockquote><p>输入: root = [3,4,5,1,3,null,1]<br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</p></blockquote><blockquote><p>提示：<br>树的节点数在 [1, 10^4] 范围内<br>0 &lt;= Node.val &lt;= 10^4</p></blockquote><p><strong>题目解析</strong></p><p>对于任意一个树节点，我们都有两种选择，要么偷，要么不偷。如果选择了偷当前这个节点，那么则不能考虑当前节点的孩子节点，应该取考虑孙子节点。如果选择不偷当前这个节点，则可以考虑当前节点的孙子节点。在两种操作中选择最大的即可。</p><p>值得注意的是，这里不适合用数组进行缓存，因为状态是一个TreeNode，因此选择用哈希表来进行缓存。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 调用递归函数，返回最大金额</span><br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 哈希表，用于记录每个节点的最大金额</span><br>    HashMap&lt;TreeNode, Integer&gt; mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 递归函数，计算以当前节点为根节点的子树的最大金额</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-comment">// 如果当前节点为空，返回0</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果哈希表中包含当前节点，直接返回哈希表中存储的结果</span><br>        <span class="hljs-keyword">if</span> (mem.containsKey(node)) <span class="hljs-keyword">return</span> mem.get(node);<br>        <br>        <span class="hljs-comment">// 选当前节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) lf = dfs(node.left.left) + dfs(node.left.right);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) rt = dfs(node.right.left) + dfs(node.right.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">select</span> <span class="hljs-operator">=</span> node.val + lf + rt;<br>        <br>        <span class="hljs-comment">// 不选当前节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">unselect</span> <span class="hljs-operator">=</span> dfs(node.left) + dfs(node.right);<br>        <br>        <span class="hljs-comment">// 取选和不选当前节点的最大值作为结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Math.max(select, unselect);<br>        <br>        <span class="hljs-comment">// 将计算得到的结果存入哈希表中</span><br>        mem.put(node, ans);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            unsel = dfs(node.left) + dfs(node.right)<br><br>            sel = node.val<br>            <span class="hljs-keyword">if</span> node.left:<br>                sel += dfs(node.left.left) + dfs(node.left.right)<br>            <span class="hljs-keyword">if</span> node.right:<br>                sel += dfs(node.right.left)  + dfs(node.right.right)<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(unsel, sel)<br><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h3 id="目标和"><a class="markdownIt-Anchor" href="#目标和"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>‘+’</code> 或 <code>‘-’</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><p>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>‘+’</code> ，在 1 之前添加 <code>‘-’</code> ，然后串联起来得到表达式 <code>“+2-1”</code> 。</p><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">示例 1：<br>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br><br>示例 2：<br>输入：nums = [1], target = 1<br>输出：1<br>提示：<br>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-<span class="hljs-number"> 1000 </span>&lt;= target &lt;= 1000<br></code></pre></td></tr></table></figure><p><strong>题目解析</strong></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329952.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>题目明显地说了每个数要么加+号，要么加-号，因此递归方向就是两个。只要最终所有元素遍历完并且和为target的时候，就有一种答案，表达式如下：</p><p><code>f(i, j) = f(i + 1, j + nums[i]) + f(i + 1, j - nums[i])</code></p><p>递归三个核心如下：</p><ul><li>递归参数：<code>idx</code> 当前遍历元素的下标，<code>sum</code> 当前和</li><li>出口：当 <code>idx ≥ nums.length</code></li><li>方向：<code>+</code>号和<code>-</code>号</li></ul><p>这里的记忆化数组mem需要注意的一个点：第二个维度sum是有可能存在负数的，但是数组下标不能表示负数，因此，我们需要讲sum总体加1000，避免出现负数的情况（数组总和是[0, 1000]）。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 找到目标和的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 初始化备忘录数组</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][<span class="hljs-number">2010</span>];<br>        <span class="hljs-comment">// 将备忘录数组所有元素初始化为-1，表示未计算过</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) Arrays.fill(mem[i], -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 调用递归函数，返回符合条件的方案数</span><br>        <span class="hljs-keyword">return</span> dfs(nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, target, nums);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 备忘录数组，用于记录计算结果</span><br>    <span class="hljs-type">int</span>[][] mem;<br>    <br>    <span class="hljs-comment">// 递归函数，计算从第idx个数到第0个数的方案数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果idx小于0，表示已经遍历完所有数，返回1或0（取决于sum是否等于target）</span><br>        <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sum == target ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过该索引位置的结果，则直接返回备忘录中的结果</span><br>        <span class="hljs-keyword">if</span> (mem[idx][sum + <span class="hljs-number">1000</span>] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> mem[idx][sum + <span class="hljs-number">1000</span>];<br>        <br>        <span class="hljs-comment">// 计算选择+和选择-两种情况下的方案数之和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(idx - <span class="hljs-number">1</span>, sum + nums[idx], target, nums) +<br>                  dfs(idx - <span class="hljs-number">1</span>, sum - nums[idx], target, nums);<br>        <br>        <span class="hljs-comment">// 将计算得到的方案数存入备忘录数组中</span><br>        mem[idx][sum + <span class="hljs-number">1000</span>] = ans;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTargetSumWays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">idx, Sum</span>):<br>            <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> Sum == target <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> dfs(idx + <span class="hljs-number">1</span>, Sum + nums[idx]) + dfs(idx + <span class="hljs-number">1</span>, Sum - nums[idx])<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="最小路径和"><a class="markdownIt-Anchor" href="#最小路径和"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102329654.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p></blockquote><blockquote><p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 200<br>0 &lt;= grid[i][j] &lt;= 100</p></blockquote><p><strong>题目解析</strong></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330833.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>对于任意节点(i, j)，每次可以走的方向只有两个，要么向下走，要么向右走。每次取最小值即可。式子如下：</p><p><code>f(i, j) = min(f(i + 1, j), f(i, j + 1)) + grid[i][j]</code></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <br>    <span class="hljs-comment">// minPathSum 方法用于计算网格 grid 从左上角到右下角的最小路径和</span><br>    <span class="hljs-comment">// 只能向下或向右移动</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 获取网格的行数和列数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-comment">// 初始化备忘录数组 mem，用于存储已经计算过的路径和，避免重复计算</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>        <span class="hljs-comment">// 使用 Arrays.fill 方法将备忘录数组 mem 填入 -1，表示初始时未计算过</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            Arrays.fill(mem[i], -<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 调用 dfs 方法从网格的左上角 (0, 0) 开始进行深度优先搜索</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, row, col, grid);<br>    &#125;<br>    <br>    <span class="hljs-comment">// mem 备忘录数组，用于存储已经计算过的路径和</span><br>    <span class="hljs-type">int</span>[][] mem;<br>    <br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于计算从位置 (i, j) 开始到右下角的最小路径和</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 判断是否到达右下角</span><br>        <span class="hljs-keyword">if</span> (i == row - <span class="hljs-number">1</span> &amp;&amp; j == col - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 如果到达右下角，返回该位置的值</span><br>            <span class="hljs-keyword">return</span> grid[i][j];<br>        &#125;<br>        <span class="hljs-comment">// 如果当前位置超出网格范围，则返回一个足够大的数，表示不可达</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= row || j &gt;= col) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过当前位置的路径和，则直接返回</span><br>        <span class="hljs-keyword">if</span> (mem[i][j] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[i][j];<br>        &#125;<br>        <br>        <span class="hljs-comment">// 计算向右移动的路径和，即不包括当前格子的值，加上当前格子的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>, row, col, grid) + grid[i][j];<br>        <span class="hljs-comment">// 计算向下移动的路径和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, j, row, col, grid) + grid[i][j];<br>        <br>        <span class="hljs-comment">// 取向右和向下两条路径的较小值，并存储到备忘录中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Math.min(right, down);<br>        mem[i][j] = ans;<br>        <br>        <span class="hljs-comment">// 返回当前位置的最小路径和</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            <span class="hljs-keyword">if</span> x == m - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == n - <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> grid[x][y]<br>            <span class="hljs-keyword">if</span> x &gt;= m <span class="hljs-keyword">or</span> y &gt;= n: <span class="hljs-keyword">return</span> <span class="hljs-number">2000000</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(x + <span class="hljs-number">1</span>, y), dfs(x, y + <span class="hljs-number">1</span>)) + grid[x][y]<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h3 id="不同路径"><a class="markdownIt-Anchor" href="#不同路径"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330588.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入：m = 3, n = 7<br>输出：28</p></blockquote><p>示例 2：</p><blockquote><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。<br>1.向右 -&gt; 向下 -&gt; 向下<br>2.向下 -&gt; 向下 -&gt; 向右<br>3.向下 -&gt; 向右 -&gt; 向下</p></blockquote><p>示例 3：</p><blockquote><p>输入：m = 7, n = 3<br>输出：28</p></blockquote><p>示例 4：</p><blockquote><p>输入：m = 3, n = 3<br>输出：6</p></blockquote><blockquote><p>提示：<br>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10^9</p></blockquote><p><strong>题目解析</strong></p><p>递归思路如下：每次可以选择向下走和向右走。求总和即可。式子如下：</p><p><code>f(i, j) = f(i + 1, j) + f(i, j + 1)</code></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 定义一个二维数组用于记忆化搜索，初始值设为-1表示未计算过</span><br>    <span class="hljs-type">int</span>[][] mem;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算从左上角到右下角有多少种不同的路径。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m 目标网格的行数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 目标网格的列数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 不同路径的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化记忆化搜索的二维数组，大小为(m+1) x (n+1)，预留一位用于处理边界情况</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 将数组所有元素初始化为-1，表示尚未计算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt;= m ; i++) &#123;<br>            Arrays.fill(mem[i], -<span class="hljs-number">1</span> );<br>        &#125;<br>        <br>        <span class="hljs-comment">// 从起点(0, 0)开始进行深度优先搜索计算不同路径数量</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 深度优先搜索计算从(i, j)到(m-1, n-1)的不同路径数量。</span><br><span class="hljs-comment">     * 利用记忆化递归减少重复计算。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i 当前所在的行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j 当前所在的列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m 目标网格的行数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 目标网格的列数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 从当前位置到终点的不同路径数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 如果到达终点，返回1表示找到一种路径</span><br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果越界，返回0表示此路径无效</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果当前位置的结果已经计算过，直接从记忆数组中返回结果</span><br>        <span class="hljs-keyword">if</span> (mem[i][j] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[i][j];<br>        &#125;<br>        <br>        <span class="hljs-comment">// 向下和向右两个方向探索，累加两种情况下的路径数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span>  dfs(i + <span class="hljs-number">1</span>, j, m, n) + dfs(i, j + <span class="hljs-number">1</span>, m, n);<br>        <br>        <span class="hljs-comment">// 将计算结果存入记忆数组，避免重复计算</span><br>        mem[i][j] = ans;<br>        <br>        <span class="hljs-comment">// 返回计算结果</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            <span class="hljs-keyword">if</span> x == m - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == n - <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> x == m <span class="hljs-keyword">or</span> y == n: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> dfs(x + <span class="hljs-number">1</span>, y) + dfs(x, y + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="不同路径-ii"><a class="markdownIt-Anchor" href="#不同路径-ii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102330416.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>1.向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>2.向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p></blockquote><p>示例 2：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102331236.png" srcset="/img/loading.gif" lazyload alt="示例2"></p><blockquote><p>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1</p></blockquote><blockquote><p>提示：<br>m == obstacleGrid.length<br>n == obstacleGrid[i].length<br>1 &lt;= m, n &lt;= 100<br>obstacleGrid[i][j] 为 0 或 1</p></blockquote><p><strong>题目解析</strong></p><p>每次递归可以走的方向有两种：1.向下走 2.向右走</p><p>当走到终点的时候说明有一种走法，返回1。如果走出边界或者遇到障碍物，说明此路不通，返回0。式子如下：</p><p><code>f(i, j) = f(i + 1, j) + f(i, j + 1)</code></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// uniquePathsWithObstacles 方法用于计算在给定的有障碍物的网格中，从左上角到右下角的唯一路径数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-comment">// 获取网格的行数 m 和列数 n</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 初始化备忘录数组 mem，用于存储已经计算过的路径数量，避免重复计算</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">// 使用 Arrays.fill 方法将备忘录数组 mem 填入 -1，表示初始时未计算过</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            Arrays.fill(mem[i], -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 调用 dfs 方法从网格的左上角 (0, 0) 开始进行深度优先搜索</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, obstacleGrid);<br>    &#125;<br><br>    <span class="hljs-comment">// mem 备忘录数组，用于存储已经计算过的位置的路径数量</span><br>    <span class="hljs-type">int</span>[][] mem;<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于计算从位置 (i, j) 开始到右下角 (m - 1, n - 1) 的唯一路径数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-comment">// 如果当前位置超出网格范围或存在障碍物，则无法通过，返回 0</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果到达右下角，存在 1 条路径</span><br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过当前位置的路径数量，则直接返回该值</span><br>        <span class="hljs-keyword">if</span> (mem[i][j] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[i][j];<br>        &#125;<br>        <span class="hljs-comment">// 否则，计算当前位置向下和向右两个方向的路径数量，并将它们相加</span><br>        <span class="hljs-comment">// 将计算结果存储到备忘录中，然后返回</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, j, m, n, obstacleGrid) + dfs(i, j + <span class="hljs-number">1</span>, m, n, obstacleGrid);<br>        mem[i][j] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(obstacleGrid), <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            <span class="hljs-keyword">if</span> x == m - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == n - <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> obstacleGrid[x][y] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x &gt;= m <span class="hljs-keyword">or</span> y &gt;= n <span class="hljs-keyword">or</span> obstacleGrid[x][y] == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> dfs(x + <span class="hljs-number">1</span>, y) + dfs(x, y + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h3 id="单词拆分"><a class="markdownIt-Anchor" href="#单词拆分"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">单词拆分</a></h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例 1：</p><blockquote><p>输入: s = “leetcode”, wordDict = [“leet”, “code”]</p><p>输出: true</p><p>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p></blockquote><p>示例 2：</p><blockquote><p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]</p><p>输出: true</p><p>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。</p><p>注意，你可以重复使用字典中的单词。</p></blockquote><p>示例 3：</p><blockquote><p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]</p><p>输出: false</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= s.length &lt;= 300</p><p>1 &lt;= wordDict.length &lt;= 1000</p><p>1 &lt;= wordDict[i].length &lt;= 20</p><p>s 和 wordDict[i] 仅有小写英文字母组成</p><p>wordDict 中的所有字符串 互不相同</p></blockquote><p><strong>题目解析</strong></p><p>依然采用递归的思想进行分析。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102331305.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>以样例1为例，s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]。我们从s的下标为0开始往后枚举，发现字符串”cat”,“cats”存在于wordDict中，因此可以进行递归， 下一次递归应该从下标为4也就是3和4开始。因此：</p><ul><li>递归的参数：idx 从idx往后开始枚举</li><li>出口：如果idx到达s.length()后，说明s整段都可以用wordDict组成</li><li>方向：只要s.substring(idx, j)包含在wordDict中就可进行递归。</li></ul><p>以下代码中的mem数组含义：mem[idx]表示的是s.substring(idx, s.length())是否可以由wordDict组成。初始值0表示这个状态还没算过，当mem[idx]<mark>1的时候表示s.substring(idx, s.length())可以由wordDict组成；当mem[idx]</mark>-1的时候表示不可以由wordDict组成。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// wordBreak 方法用于检查字符串 s 是否可以由 wordDict 词汇表中的单词组成</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-comment">// 使用 HashSet 存储 wordDict 中的单词，以便快速查找</span><br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-comment">// 初始化备忘录数组 mem，长度与字符串 s 相同</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 调用 dfs 方法从字符串 s 的索引 0 开始进行深度优先搜索</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, s, set);<br>    &#125;<br><br>    <span class="hljs-comment">// mem 备忘录数组，用于存储已经计算过的索引位置的结果，0 表示未知，1 表示 true，-1 表示 false</span><br>    <span class="hljs-type">int</span>[] mem;<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于检查从索引 idx 开始的字符串 s 是否可以由 wordDict 词汇表中的单词组成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, String s, HashSet&lt;String&gt; set)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引 idx 大于等于字符串 s 的长度，说明已经处理到字符串末尾，返回 true</span><br>        <span class="hljs-keyword">if</span> (idx &gt;= s.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过当前索引 idx 的结果，则直接返回该结果</span><br>        <span class="hljs-keyword">if</span> (mem[idx] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[idx] == <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 初始化结果变量 ans 为 false</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 从当前索引 idx 开始，遍历字符串 s，直到字符串结束</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> idx; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 使用 substring 方法获取从 idx 到 i 的子串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.substring(idx, i);<br>            <span class="hljs-comment">// 如果 HashSet set 包含当前子串 temp，则递归检查从索引 i 开始的字符串 s 是否可以由 wordDict 词汇表中的单词组成</span><br>            <span class="hljs-comment">// 并将结果累加到 ans 中</span><br>            <span class="hljs-keyword">if</span> (set.contains(temp)) &#123;<br>                ans = ans || dfs(i, s, set);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将计算结果存储到备忘录数组 mem 中，如果 ans 为 true，则记为 1，否则记为 -1</span><br>        mem[idx] = ans ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 返回计算结果 ans</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">s</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            res = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>( s) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> (s[:j] <span class="hljs-keyword">in</span> wordDict):<br>                    res = dfs( s[j:]) <span class="hljs-keyword">or</span> res<br>            <span class="hljs-keyword">return</span> res<br>        <span class="hljs-keyword">return</span> dfs(s)<br></code></pre></td></tr></table></figure><h3 id="整数替换"><a class="markdownIt-Anchor" href="#整数替换"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-replacement/">整数替换</a></h3><p>给定一个正整数 <code>n</code> ，你可以做如下操作：</p><p>如果 <code>n</code> 是偶数，则用 <code>n / 2</code> 替换 <code>n</code> 。</p><p>如果 <code>n</code> 是奇数，则可以用 <code>n + 1</code>或<code>n - 1</code>替换 <code>n</code> 。</p><p>返回 <code>n</code> 变为 <code>1</code> 所需的 <strong>最小替换次数</strong> 。</p><p>示例 1：</p><blockquote><p>输入：n = 8</p><p>输出：3</p><p>解释：8 -&gt; 4 -&gt; 2 -&gt; 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 7</p><p>输出：4</p><p>解释：7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</p><p>或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 4</p><p>输出：2</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= n &lt;= 2^31 - 1</p></blockquote><p><strong>题目解析</strong></p><p>此题很明显可以使用递归来做，题目已经明确告诉我们递归的方向：如果n是偶数的话递归方向就是n / 2，如果是奇数的话应该是n + 1 和 n - 1。不难发现如果n是奇数，那么n - 1和n + 1是偶数，那么下一次递归方向就必然是 (n + 1) / 2 和 (n - 1) / 2，因此不难写出以下代码。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333149.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>其中mem的含义是mem[n]：n变为1的最少操作数。</p><p>注意：这题如果采用自底向上的动态规划的式子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <br>	dp[i] = dp[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>: <br>	dp[i] = min(dp[(i + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>], dp[(i - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>]) + <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>但是这样做的时间复杂度是O(n)，而n的范围是2^31次方，所以是会超时的。采用递归的做法则是logn的复杂度，所以此题要使用递归的方式进行求解。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// integerReplacement 方法用于计算将整数 n 替换为 1 所需要的最小操作次数</span><br>    <span class="hljs-comment">// 每次操作可以乘以 2 或减去 1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerReplacement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 调用 dfs 方法开始计算，传入参数 n</span><br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-comment">// mem 用于存储已经计算过的整数 n 的替换步数，避免重复计算</span><br>    HashMap&lt;Integer, Integer&gt; mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于计算将整数 n 替换为 1 所需的最小操作步数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 如果整数 n 已经为 1，则不需要任何操作，返回 0</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果已经计算过整数 n 的替换步数，则直接从 mem 中获取结果</span><br>        <span class="hljs-keyword">if</span> (mem.containsKey(n)) &#123;<br>            <span class="hljs-keyword">return</span> mem.get(n);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化答案变量 ans</span><br>        <span class="hljs-comment">// 如果整数 n 是偶数，则可以除以 2，操作步数为 dfs(n / 2) + 1</span><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            ans = dfs(n / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果整数 n 是奇数，则可以选择减去 1 或加上 1 使其变为偶数，取两种方式的最小操作步数</span><br>            <span class="hljs-comment">// 操作步数为 Math.min(dfs((n - 1) / 2), dfs((n + 1) / 2)) + 2</span><br>            ans = Math.min(dfs((n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>), dfs((n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) + <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将计算得到的操作步数存入 mem，键为 n，值为 ans</span><br>        mem.put(n, ans);<br>        <span class="hljs-comment">// 返回整数 n 的替换操作步数 ans</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">integerReplacement</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">cur</span>):<br>            <span class="hljs-keyword">if</span> cur == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> cur % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> dfs(cur // <span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(cur + <span class="hljs-number">1</span>), dfs(cur - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> dfs(n)<br></code></pre></td></tr></table></figure><h3 id="跳跃游戏"><a class="markdownIt-Anchor" href="#跳跃游戏"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><blockquote><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p></blockquote><blockquote><p>提示：<br>1 &lt;= nums.length &lt;= 3 * 10^4<br>0 &lt;= nums[i] &lt;= 10^5</p></blockquote><p><strong>题目解析</strong></p><p>解法1——记忆化搜索</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333734.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>递归的思路：从下标为0开始走，可以往后走的步数为[1, nums[0]]，每个走法都去尝试一次，因此我们可以设计出如下递归函数：</p><ul><li>递归参数：idx表示当前位置</li><li>递归出口：当走到走后一个位置的时候return true</li><li>递归方向：idx + j , j ∈[1,nums[idx]]</li></ul><p>mem[idx] = 0表示idx这个位置还没走过</p><p>mem[idx] = 1表示这个位置可以走到末尾</p><p>mem[idx] = -1表示走不到</p><p>解法2——贪婪算法</p><p>此题可以用贪心算法进行解答，后面贪心算法的模块我们再来讲解。</p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// canJump 方法用于判断给定的数组 nums 是否可以通过跳跃到达最后一个位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化备忘录数组 mem，长度与 nums 相同，所有元素初始化为 0</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 从索引 0 开始调用 dfs 方法进行深度优先搜索</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums);<br>    &#125;<br><br>    <span class="hljs-comment">// mem 备忘录数组，用于存储已经计算过的索引位置的结果，0 表示未计算，1 表示可到达，-1 表示不可到达</span><br>    <span class="hljs-type">int</span>[] mem;<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于判断从索引 idx 开始的位置是否可以到达数组的最后一个位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引 idx 已经到达或超过数组的末尾，则认为可以到达最后一个位置</span><br>        <span class="hljs-keyword">if</span> (idx &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过当前索引 idx 的结果，则直接返回结果</span><br>        <span class="hljs-keyword">if</span> (mem[idx] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[idx] == <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历当前索引 idx 可以跳跃到达的所有可能位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[idx]; i++) &#123;<br>            <span class="hljs-comment">// 如果从 idx + i 的位置可以到达最后一个位置，则将 mem[idx] 设置为 1 并返回 true</span><br>            <span class="hljs-keyword">if</span> (dfs(idx + i, nums)) &#123;<br>                mem[idx] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果以上跳跃位置都无法到达最后一个位置，则将 mem[idx] 设置为 -1 并返回 false</span><br>        mem[idx] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canJump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(nums) -<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, nums[i]+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dfs(i+j): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="跳跃游戏-ii"><a class="markdownIt-Anchor" href="#跳跃游戏-ii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>示例 1:</p><blockquote><p>输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [2,3,0,1,4]<br>输出: 2</p></blockquote><blockquote><p>提示:<br>1 &lt;= nums.length &lt;= 104<br>0 &lt;= nums[i] &lt;= 1000</p></blockquote><p><strong>题目解析</strong></p><p>递归的思路如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405102333071.png" srcset="/img/loading.gif" lazyload alt="题目解析"></p><p>从下标为 <code>idx</code> 往后走，可以走的台阶数是 <code>idx + j</code> , 其中 <code>j∈[1,nums[idx]]</code> ，各个方向中我们需要选取最小值。</p><p>递归的三个核心如下：</p><ul><li>递归参数：<code>idx</code> 表示当前所在的台阶</li><li>递归出口：当走到最后一个台阶的时候返回</li><li>递归方向：<code>idx + j</code>, 其中 <code>j∈[1,nums[idx]]</code>，每次取最小值即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// jump 方法用于计算数组 nums 中到达最后一个位置的最少跳跃次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化备忘录数组 mem，长度与 nums 相同，所有元素初始化为 -1 表示未计算</span><br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(mem, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 从索引 0 开始调用 dfs 方法进行深度优先搜索，计算到达数组末尾的最少跳跃次数</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums);<br>    &#125;<br><br>    <span class="hljs-comment">// mem 备忘录数组，用于存储每个索引到达数组末尾所需的最少跳跃次数</span><br>    <span class="hljs-type">int</span>[] mem;<br><br>    <span class="hljs-comment">// dfs 方法是一个递归方法，用于计算从索引 idx 开始到达数组末尾的最少跳跃次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果当前索引 idx 已经到达或超过数组的末尾，则无需跳跃，返回 0</span><br>        <span class="hljs-keyword">if</span> (idx &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果备忘录中已经计算过当前索引 idx 的跳跃次数，则直接返回该值</span><br>        <span class="hljs-keyword">if</span> (mem[idx] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mem[idx];<br>        &#125;<br>        <span class="hljs-comment">// 初始化 ans 为一个较大的数，用于存储当前索引到达末尾的最小跳跃次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000010</span>;<br>        <span class="hljs-comment">// 遍历当前索引 idx 可以跳跃到达的所有可能位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[idx]; i++) &#123;<br>            <span class="hljs-comment">// 对于每个可以跳跃到达的位置，计算从该位置到达末尾的最少跳跃次数，并加上当前步的 1 次跳跃</span><br>            <span class="hljs-comment">// 使用 Math.min 更新 ans 为到达末尾的全局最小跳跃次数</span><br>            ans = Math.min(ans, dfs(idx + i, nums) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将计算得到的最小跳跃次数存储到备忘录 mem 中</span><br>        mem[idx] = ans;<br>        <span class="hljs-comment">// 返回当前索引 idx 到达末尾的最少跳跃次数</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            ans = inf<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, nums[i]+<span class="hljs-number">1</span>):<br>                ans = <span class="hljs-built_in">min</span>(ans, dfs(i+j) + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> ans<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分</div><div>https://fulequn.github.io/2024/05/Article202405101/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年5月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/05/Article202405102/" title="算法训练-6高效算法部分 单调队列"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法训练-6高效算法部分 单调队列</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/05/Article202405081/" title="超卖问题（图解 + 秒懂 + 史上最全）"><span class="hidden-mobile">超卖问题（图解 + 秒懂 + 史上最全）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>