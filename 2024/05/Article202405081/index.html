<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="前言 先来就库存超卖的问题作描述：一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是众多电子商务网站程序员头疼的问题，这同时也是最基本的问题。 在秒杀系统设计中，超卖是一个经典、常见的问题，任何商品都会有数量上限，如何避免成功下订单"><meta property="og:type" content="article"><meta property="og:title" content="超卖问题（图解 + 秒懂 + 史上最全）"><meta property="og:url" content="https://fulequn.github.io/2024/05/Article202405081/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="前言 先来就库存超卖的问题作描述：一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是众多电子商务网站程序员头疼的问题，这同时也是最基本的问题。 在秒杀系统设计中，超卖是一个经典、常见的问题，任何商品都会有数量上限，如何避免成功下订单"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107058.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107749.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107285.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108763.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108128.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108094.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108938.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109519.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109293.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109798.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109991.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109708.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110346.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110049.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110480.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110147.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111033.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111382.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111077.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111732.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082112097.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113621.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113836.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113733.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082114910.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082114407.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115036.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115140.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115901.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082116508.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082118654.png"><meta property="article:published_time" content="2024-05-08T13:05:13.000Z"><meta property="article:modified_time" content="2024-05-18T14:35:08.111Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107058.png"><title>超卖问题（图解 + 秒懂 + 史上最全） - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="超卖问题（图解 + 秒懂 + 史上最全）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-05-08 21:05" pubdate>2024年5月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>124 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">超卖问题（图解 + 秒懂 + 史上最全）</h1><div class="markdown-body"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>先来就库存超卖的问题作描述：一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是众多电子商务网站程序员头疼的问题，这同时也是最基本的问题。</p><p>在秒杀系统设计中，超卖是一个经典、常见的问题，任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难点。</p><h1 id="一-问题描述"><a class="markdownIt-Anchor" href="#一-问题描述"></a> 一、问题描述</h1><p>在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常。问题：</p><p>当商品 A 一共有库存 15 件，用户甲先下单 10 件，用户乙下单 8 件，这时候库存只能满足一个人下单成功，如果两个人同时提交，就出现了超卖的问题。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107058.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20191129105250547.png"></p><h1 id="二-解决的三种方案"><a class="markdownIt-Anchor" href="#二-解决的三种方案"></a> 二、解决的三种方案</h1><ul><li>悲观锁</li></ul><p>通过悲观锁解决超卖</p><ul><li>乐观锁</li></ul><p>通过乐观锁解决超卖</p><ul><li>分段执行的排队方案</li></ul><p>通过分段执行的排队方案解决超卖</p><h2 id="解决方案-1-悲观锁"><a class="markdownIt-Anchor" href="#解决方案-1-悲观锁"></a> 解决方案 1: 悲观锁</h2><p>当查询某条记录时，即让数据库为该记录加锁，锁住记录后别人无法操作，使用类似如下语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">beginTranse(开启事务)<br><span class="hljs-keyword">try</span>&#123;<br>    query(<span class="hljs-string">&#x27;select amount from s_store where goodID = 12345&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(库存 &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//quantity为请求减掉的库存数量</span><br>        query(<span class="hljs-string">&#x27;update s_store set amount = amount - quantity where goodID = 12345&#x27;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>( Exception e )&#123;<br>    rollBack(回滚)<br>&#125;<br>commit(提交事务)<br></code></pre></td></tr></table></figure><blockquote><p>问题：</p></blockquote><p>注意，上面的代码容易出现死锁，采用不多。</p><blockquote><p>有社群小伙伴，对死锁的的原因比较关心，这里简单分析一下。</p></blockquote><blockquote><p>上面的语句，可能出现死锁的简单的原因，在事务的隔离级别为 Serializable 时，假设事务 t1 通过 select 拿到了共享锁，而其他事务如果拿到了 排他锁，此时 t1 去拿排他锁的时候， 就有可能会出现死锁, 注意，这里是可能，并不是一定。实际的原因，与事务的隔离级别和语句的复杂度，都有关系。</p><p>总之，避免死锁的方式之一（稍后介绍）：为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT … FOR UPDATE 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p></blockquote><blockquote><p>解决方案：一般提前采用 select for update，提前加上写锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">beginTranse(开启事务)<br><span class="hljs-keyword">try</span>&#123;<br>    query(<span class="hljs-string">&#x27;select amount from s_store where goodID = 12345   for update&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(库存 &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//quantity为请求减掉的库存数量</span><br>        query(<span class="hljs-string">&#x27;update s_store set amount = amount - quantity where goodID = 12345&#x27;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>( Exception e )&#123;<br>    rollBack(回滚)<br>&#125;<br>commit(提交事务)<br></code></pre></td></tr></table></figure><h3 id="1-行锁和表锁"><a class="markdownIt-Anchor" href="#1-行锁和表锁"></a> 1 行锁和表锁</h3><p><strong>行锁：分为 共享锁 和 排它锁。</strong></p><ul><li><strong>共享锁又称：读锁</strong>。当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁。</li></ul><blockquote><p>上共享锁的写法：lock in share mode</p></blockquote><blockquote><p>例如： select math from zje where math&gt;60 lock in share mode；</p></blockquote><ul><li><strong>排它锁又称：写锁</strong>。当一个事务对某几个上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁。包括写锁。</li></ul><blockquote><p>上排它锁的写法：for update</p></blockquote><blockquote><p>例如：select math from zje where math &gt;60 for update；</p></blockquote><hr><p><strong>死锁</strong></p><ul><li>死锁：例如说两个事务，事务 A 锁住了 15 行，同时事务 B 锁住了 610 行，此时事务 A 请求锁住 610 行，就会阻塞直到事务 B 施放 610 行的锁，而随后事务 B 又请求锁住 15 行，事务 B 也阻塞直到事务 A 释放 15 行的锁。死锁发生时，会产生 Deadlock 错误。</li></ul><p><strong>表锁</strong>：不会出现死锁，发生锁冲突几率高，并发低。</p><blockquote><p>表锁是对表操作的，所以自然锁住全表的表锁就不会出现死锁。但是表锁效率低。</p></blockquote><ul><li>行锁：会出现死锁，发生锁冲突几率低，并发高。</li></ul><hr><p><strong>使用行锁需要注意的点：</strong></p><ol><li><p>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</p></li><li><p>两个事务不能锁同一个索引，例如：</p></li></ol><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">事务A先执行：<br><span class="hljs-built_in">select</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">from</span> zje where <span class="hljs-built_in">math</span>&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">for</span> update;<br><br>事务B再执行：<br><span class="hljs-built_in">select</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">from</span> zje where <span class="hljs-built_in">math</span>&lt;<span class="hljs-number">60</span> <span class="hljs-keyword">for</span> update；<br>这样的话，事务B是会阻塞的。如果事务B把 <span class="hljs-built_in">math</span>索引换成其他索引就不会阻塞，<br>但注意，换成其他索引锁住的行不能和<span class="hljs-built_in">math</span>索引锁住的行有重复。<br></code></pre></td></tr></table></figure><p><strong>3</strong>.insert ，delete ， update 在事务中都会自动默认加上排它锁。</p><p>实现：</p><table><thead><tr><th>会话 1：</th><th>会话 2：</th></tr></thead><tbody><tr><td>begin；select math from zje where math&gt;60 for update；</td><td>begin；update zje set math=99 where math=68；阻塞</td></tr></tbody></table><h3 id="2-myisam-与-innodb-的区别"><a class="markdownIt-Anchor" href="#2-myisam-与-innodb-的区别"></a> 2 MyISAM 与 InnoDB 的区别</h3><p><strong>介绍</strong></p><p>**MyISAM：**MyISAM 是默认存储引擎（Mysql5.1 前），每个 MyISAM 在磁盘上存储成三个文件，每一个文件的名字均以表的名字开始，扩展名指出文件类型。</p><ul><li>.frm 文件存储表定义</li><li>·MYD (MYData) 文件存储表的数据</li><li>.MYI (MYIndex) 文件存储表的索引</li></ul><p>**InnoDB：**MySQL 的默认存储引擎，给 MySQL 提供了具有事务 (transaction)、回滚(rollback) 和崩溃修复能力 (crash recovery capabilities)、多版本并发控制(multi-versioned concurrency control) 的事务安全 (transaction-safe (ACID compliant)) 型表。InnoDB 提供了行级锁(locking on row level)，提供与 Oracle 类似的不加锁读取(non-locking read in SELECTs)。</p><p><strong>MyISAM 与 InnoDB 的区别</strong></p><ol><li><p>InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；</p></li><li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MyISAM 会失败；</p></li><li><p>聚集索引 VS 非聚集索引</p><blockquote><p>InnoDB 是聚集索引，使用 B+Tree 作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按 B+Tree 组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p></blockquote></li></ol><p><strong>InnoDB 的 B + 树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值。</strong></p><p><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20180923094753230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">https://img-blog.csdn.net/20180923094753230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</a></p><blockquote><p>但是， MyISAM 是非聚集索引，也是使用 B+Tree 作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p></blockquote><p><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20180923094753224?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">https://img-blog.csdn.net/20180923094753224?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</a></p><p><strong>总结</strong></p><p>也就是说：InnoDB 的 B + 树<strong>主键索引</strong>的叶子节点就是数据文件，<strong>辅助索引</strong>的叶子节点是主键的值；而 MyISAM 的 B + 树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p><hr><ol><li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何 WHERE 条件）；</li></ol><blockquote><p>那么为什么 InnoDB 没有了这个变量呢？<br>因为 InnoDB 的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此 count 统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB 会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB 还会尝试去遍历其他聚簇索引。<br>如果索引并没有完全处于 InnoDB 维护的缓冲区（Buffer Pool）中，count 操作会比较费时。可以建立一个记录总行数的表并让你的程序在 INSERT/DELETE 时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试 SHOW TABLE STATUS。</p></blockquote><ol><li>InnoDB 不支持全文索引，而 MyISAM 支持全文索引，在涉及全文索引领域的查询效率上 MyISAM 速度更快高；PS：5.7 以后的 InnoDB 支持全文索引了</li><li>MyISAM 表格可以被压缩后进行查询操作</li><li>InnoDB 支持表、行 (默认) 级锁，而 MyISAM 支持表级锁</li></ol><blockquote><p>InnoDB 的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">例如：<br>    t_user(uid, uname, age, sex) innodb;<br><br>    uid PK<br>    无其他索引<br>    update t_user <span class="hljs-built_in">set</span> <span class="hljs-attribute">age</span>=10 where <span class="hljs-attribute">uid</span>=1;             命中索引，行锁。<br><br>    update t_user <span class="hljs-built_in">set</span> <span class="hljs-attribute">age</span>=10 where uid != 1;           未命中索引，表锁。<br><br>    update t_user <span class="hljs-built_in">set</span> <span class="hljs-attribute">age</span>=10 where <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;chackca&#x27;</span>;    无索引，表锁。<br></code></pre></td></tr></table></figure><ol><li>InnoDB 表必须有唯一索引（如主键）（用户没有指定的话会自己找 / 生产一个隐藏列 Row_id 来充当默认主键），而 MyISAM 可以没有</li><li>Innodb 存储文件有 frm、ibd，而 MyISAM 是 frm、MYD、MYI</li></ol><blockquote><p>Innodb：frm 是表定义文件，ibd 是数据文件<br>MyISAM：frm 是表定义文件，myd 是数据文件，myi 是索引文件</p></blockquote><hr><p><strong>如何选择这两种引擎</strong>：</p><ol><li><p>是否要支持事务，如果要请选择 innodb，如果不需要可以考虑 MyISAM；</p></li><li><p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读也有写，请使用 InnoDB。</p></li><li><p>系统奔溃后，MyISAM 恢复起来更困难，能否接受；</p></li><li><p>MySQL5.5 版本开始 Innodb 已经成为 Mysql 的默认引擎 (之前是 MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用 InnoDB，至少不会差。</p></li></ol><p>InnoDB 为什么推荐使用自增 ID 作为主键？</p><blockquote><p>答：自增 ID 可以保证每次插入时 B + 索引是从右边扩展的，可以避免 B + 树和频繁合并和分裂（对比使用 UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p></blockquote><p>InnoDB 引擎的 4 大特性</p><blockquote><p>插入缓冲（insert buffer), 二次写 (double write), 自适应哈希索引 (ahi), 预读 (read ahead)</p></blockquote><h3 id="3-事务与死锁"><a class="markdownIt-Anchor" href="#3-事务与死锁"></a> 3 事务与死锁</h3><p>在 MySQL 的 InnoDB 中，预设的 <code>Tansaction isolation level</code> 为 <code>REPEATABLE READ</code>(可重读)</p><p>在 SELECT 的读取锁定主要分为两种方式：</p><ol><li><code>SELECT … LOCK IN SHARE MODE</code></li><li><code>SELECT … FOR UPDATE</code></li></ol><p>这两种方式在事务 (Transaction) 进行当中 SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit) 后才会执行。</p><p>而主要的不同在于共享锁 (lock in share mode) 在有一方事务要 Update 同一个表单时很容易造成死锁。</p><blockquote><p>简单的说，如果 SELECT 后面若要 UPDATE 同一个表单，最好使用 SELECT … UPDATE。</p></blockquote><hr><p><strong>MySQL SELECT … FOR UPDATE 的 Row Lock 与 Table Lock</strong></p><p>上面介绍过 SELECT … FOR UPDATE 的用法，不过锁定 (Lock) 的数据是判别就得要注意一下了。由于 InnoDB 预设是 <code>Row-Level Lock</code>，所以只有「明确」的指定主键，MySQL 才会执行 Row lock (只锁住被选取的数据) ，否则 MySQL 将会执行 Table Lock (将整个数据表单给锁住)。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">举个例子:<br>假设有个表单 products ，里面有 id 跟 <span class="hljs-type">name</span> 二个栏位，id 是主键。<br><br>例 <span class="hljs-number">1</span>: (明确指定主键，并且有此数据，<span class="hljs-keyword">row</span> <span class="hljs-keyword">lock</span>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id=<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br>例 <span class="hljs-number">2</span>: (明确指定主键，若查无此数据，无 <span class="hljs-keyword">lock</span>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id=<span class="hljs-string">&#x27;-1&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br>例 <span class="hljs-number">2</span>: (无主键，<span class="hljs-keyword">table</span> <span class="hljs-keyword">lock</span>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;Mouse&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br>例 <span class="hljs-number">3</span>: (主键不明确，<span class="hljs-keyword">table</span> <span class="hljs-keyword">lock</span>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id&lt;&gt;<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br>例 <span class="hljs-number">4</span>: (主键不明确，<span class="hljs-keyword">table</span> <span class="hljs-keyword">lock</span>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="4-淘宝是如何使用悲观锁的"><a class="markdownIt-Anchor" href="#4-淘宝是如何使用悲观锁的"></a> 4 淘宝是如何使用悲观锁的</h3><p>那么后端的数据库在高并发和超卖下会遇到什么问题呢？主要会有如下 3 个问题：（主要讨论写的问题，读的问题通过增加 cache 可以很容易的解决）</p><ol><li>首先 MySQL 自身对于高并发的处理性能就会出现问题，一般来说，MySQL 的处理性能会随着并发 thread 上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单 thread 的性能还要差。</li><li>其次，超卖的根结在于减库存操作是一个事务操作，需要先 select，然后 insert，最后 update -1。最后这个 - 1 操作是不能出现负数的，但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</li><li>最后，当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现争抢 InnoDB 行锁的问题，导致出现互相等待甚至死锁，从而大大降低 MySQL 的处理性能，最终导致前端页面出现超时异常。</li></ol><p>针对上述问题，如何解决呢？ 我们先看眼淘宝的高大上解决方案：</p><hr><p><strong>关闭死锁检测以提高并发处理性能</strong></p><p>在一个高并发的 MySQL 服务器上，事务会递归检测死锁，当超过一定的深度时，性能的下降会变得不可接受。Facebook 早就提出了禁止死锁检测。</p><p>我们做了一个实验，在禁止死锁检测后，TPS 得到了极大的提升，如下图所示：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107749.png" srcset="/img/loading.gif" lazyload alt></p><p>禁止死锁检测后，即使死锁发生，也不会回滚事务，而是全部等待到超时。</p><p>MySQL 的 <code>innobase_deadlock_check</code> 是在 InnoDB 里新加的系统变量，用于控制是否打开死锁检测。</p><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。</p><p>InnoDB 的并发写操作会触发死锁，InnoDB 也提供了死锁检测机制，可以通过设置 <code>innodb_deadlock_detect</code> 参数来打开或关闭死锁检测：</p><ul><li><code>innodb_deadlock_detect = on</code> 打开死锁检测，数据库发生死锁时自动回滚（默认选项）。</li><li><code>innodb_deadlock_detect = off</code> 关闭死锁检测，发生死锁时，用锁超时来处理。通过设置锁超时参数 <code>innodb_lock_wait_timeout</code> 可以在超时发生时回滚被阻塞的事务。</li></ul><h3 id="设置-mysql-事务锁超时时间-innodb_lock_wait_timeout"><a class="markdownIt-Anchor" href="#设置-mysql-事务锁超时时间-innodb_lock_wait_timeout"></a> 设置 MySQL 事务锁超时时间 <code>innodb_lock_wait_timeout</code></h3><p>MySQL 数据库采用 InnoDB 模式，默认参数 <code>innodb_lock_wait_timeout</code> 设置锁等待的时间是 50 秒，一旦数据库锁超过这个时间就会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name            <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> innodb_lock_wait_timeout <span class="hljs-operator">|</span> <span class="hljs-number">50</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> innodb_lock_wait_timeout<span class="hljs-operator">=</span><span class="hljs-number">120</span>;<br><br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name            <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> innodb_lock_wait_timeout <span class="hljs-operator">|</span> <span class="hljs-number">120</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p><strong>设置 InnoDB Monitors 方法</strong></p><p>还可以通过设置 InnDB Monitors 来进一步观察锁冲突详细信息</p><p>建立 test 库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">create</span> database test;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.20</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> use test<br>Reading <span class="hljs-keyword">table</span> information <span class="hljs-keyword">for</span> completion <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">column</span> names<br>You can turn off this feature <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> a quicker startup <span class="hljs-keyword">with</span> <span class="hljs-operator">-</span>A<br><br>Database changed<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> innodb_monitor(a <span class="hljs-type">INT</span>) engine<span class="hljs-operator">=</span>innodb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">1.04</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> innodb_tablespace_monitor(a <span class="hljs-type">INT</span>) engine<span class="hljs-operator">=</span>innodb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.70</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> innodb_lock_monitor(a <span class="hljs-type">INT</span>) engine<span class="hljs-operator">=</span>innodb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.36</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> innodb_table_monitor(a <span class="hljs-type">INT</span>) engine<span class="hljs-operator">=</span>innodb;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.08</span> sec)<br></code></pre></td></tr></table></figure><p>可以通过 show engine innodb status 命令查看死锁信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> engine innodb status \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>  Type: InnoDB<br>  Name:<br>Status:<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-10</span> <span class="hljs-number">09</span>:<span class="hljs-number">17</span>:<span class="hljs-number">10</span> <span class="hljs-number">0x7f1fbc21a700</span> INNODB MONITOR OUTPUT<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-keyword">Per</span> <span class="hljs-keyword">second</span> averages calculated <span class="hljs-keyword">from</span> the <span class="hljs-keyword">last</span> <span class="hljs-number">46</span> seconds<br><span class="hljs-comment">-----------------</span><br>BACKGROUND THREAD<br><span class="hljs-comment">-----------------</span><br>srv_master_thread loops: <span class="hljs-number">53</span> srv_active, <span class="hljs-number">0</span> srv_shutdown, <span class="hljs-number">240099</span> srv_idle<br>srv_master_thread log flush <span class="hljs-keyword">and</span> writes: <span class="hljs-number">0</span><br><span class="hljs-comment">----------</span><br>SEMAPHORES<br><span class="hljs-comment">----------</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: reservation count <span class="hljs-number">2007</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: signal count <span class="hljs-number">1987</span><br>RW<span class="hljs-operator">-</span>shared spins <span class="hljs-number">3878</span>, rounds <span class="hljs-number">5594</span>, OS waits <span class="hljs-number">1735</span><br>RW<span class="hljs-operator">-</span>excl spins <span class="hljs-number">3</span>, rounds <span class="hljs-number">91</span>, OS waits <span class="hljs-number">4</span><br>RW<span class="hljs-operator">-</span>sx spins <span class="hljs-number">1</span>, rounds <span class="hljs-number">30</span>, OS waits <span class="hljs-number">1</span><br>Spin rounds <span class="hljs-keyword">per</span> wait: <span class="hljs-number">1.44</span> RW<span class="hljs-operator">-</span>shared, <span class="hljs-number">30.33</span> RW<span class="hljs-operator">-</span>excl, <span class="hljs-number">30.00</span> RW<span class="hljs-operator">-</span>sx<br><span class="hljs-comment">------------</span><br>TRANSACTIONS<br><span class="hljs-comment">------------</span><br>Trx id counter <span class="hljs-number">78405</span><br>Purge done <span class="hljs-keyword">for</span> trx<span class="hljs-string">&#x27;s n:o &lt; 78404 undo n:o &lt; 10 state: running but idle</span><br><span class="hljs-string">History list length 21</span><br><span class="hljs-string">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="hljs-string">---TRANSACTION 421249967052640, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">FILE I/O</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">I/O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="hljs-string">I/O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="hljs-string">I/O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="hljs-string">.............................................................................</span><br><span class="hljs-string">.............................................................................</span><br><span class="hljs-string">.............................................................................</span><br></code></pre></td></tr></table></figure><p><strong>II：请求排队</strong></p><p>修改源代码，将排队提到进入引擎层前，降低引擎层面的并发度。</p><blockquote><p>如果请求一股脑的涌入数据库，势必会由于争抢资源造成性能下降，通过排队，让请求从混沌到有序，从而避免数据库在协调大量请求时过载。</p></blockquote><p>请求排队：如果请求一股脑的涌入数据库，势必会由于争抢资源造成性能下降，通过排队，让请求从混沌到有序，从而避免数据库在协调大量请求时过载。</p><p><strong>III：请求合并（组提交）</strong></p><p>请求合并（组提交），降低 server 和引擎的交互次数，降低 IO 消耗。</p><blockquote><p>甲买了一个商品，乙也买了同一个商品，与其把甲乙当做当做单独的请求分别执行一次商品库存减一的操作，不如把他们合并后统一执行一次商品库存减二的操作，请求合并的越多，效率提升的就越大。</p></blockquote><p><strong>实操建议</strong></p><p>不过结合我们的实际，死锁监测可以关闭，但是，改 mysql 源码这种高大上的解决方案显然有那么一点不切实际。</p><h2 id="innodb-锁定模式及实现机制"><a class="markdownIt-Anchor" href="#innodb-锁定模式及实现机制"></a> InnoDB 锁定模式及实现机制</h2><p>考虑到行级锁定均由各个存储引擎自行实现，而且具体实现也各有差别，而 InnoDB 是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下 InnoDB 的锁定特性。</p><p>总的来说，InnoDB 的锁定机制和 Oracle 数据库有不少相似之处。InnoDB 的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB 也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。</p><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p><p>InnoDB 的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082107285.png" srcset="/img/loading.gif" lazyload alt></p><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是 InnoDB 自动加的，不需用户干预。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及数据集加排他锁（X)；对于普通 SELECT 语句，InnoDB 不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">共享锁(S)：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br>排他锁(X)：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br></code></pre></td></tr></table></figure><p>用 <code>SELECT … IN SHARE MODE</code> 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 <code>UPDATE</code> 或者 <code>DELETE</code> 操作。</p><p>但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 <code>SELECT… FOR UPDATE</code> 方式获得排他锁。</p><hr><h3 id="间隙锁next-key-锁"><a class="markdownIt-Anchor" href="#间隙锁next-key-锁"></a> <strong>间隙锁（Next-Key 锁）</strong></h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；</p><p>对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP)”，InnoDB 也会对这个“间隙” 加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。</p><p>例：</p><p>假如 emp 表中只有 101 条记录，其 empid 的值分别是 1,2,…,100,101，下面的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empid <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB 不仅会对符合条件的 <code>empid</code> 值为 101 的记录加锁，也会对 <code>empid</code> 大于 101（这些记录并不存在）的 “间隙” 加锁。</p><p>InnoDB 使用间隙锁的目的：</p><p>（1）防止幻读，以满足相关隔离级别的要求。对于上面的例子，要是不使用间隙锁，如果其他事务插入了 empid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；</p><p>（2）为了满足其恢复和复制的需要。</p><p>很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>除了间隙锁给 InnoDB 带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：</p><p>（1）当 Query 无法利用索引的时候，InnoDB 会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</p><p>（2）当 Query 使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该 Query 的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；</p><p>（3）当 Query 在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定。</p><p>因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p>还要特别说明的是，InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。</p><h3 id="并发事务有什么什么问题应该如何解决"><a class="markdownIt-Anchor" href="#并发事务有什么什么问题应该如何解决"></a> <strong>并发事务有什么什么问题？应该如何解决？</strong></h3><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p><ul><li>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul><hr><h3 id="什么是-mvcc"><a class="markdownIt-Anchor" href="#什么是-mvcc"></a> 什么是 MVCC？</h3><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><p><strong>MVCC 是怎么工作的？</strong></p><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><p><strong>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</strong></p><ul><li>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</li><li>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</li><li>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</li><li>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</li></ul><p><strong>快照读和当前读</strong></p><p>在 mysql 中 select 分为快照读和当前读，执行下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为 <code>Serializable</code> 中不成立）</p><h3 id="select-加锁分析"><a class="markdownIt-Anchor" href="#select-加锁分析"></a> select 加锁分析</h3><p>下面六句 Sql 的区别呢</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> ?<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> ?<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> ? lock <span class="hljs-keyword">in</span> share mode<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> ? lock <span class="hljs-keyword">in</span> share mode<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> ? <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁，您能说出来嘛？</p><p>要回答这个问题，先问自己三个问题</p><ul><li>当前事务隔离级别是什么</li><li>id 列是否存在索引</li><li>如果存在索引是聚簇索引还是非聚簇索引呢？</li></ul><p>关于 mysql 的索引，啰嗦一下：</p><ul><li>InnoDB 一定存在聚簇索引，默认以主键作为聚簇索引</li><li>有几个索引，就有几棵 B + 树 (不考虑 hash 索引的情形)</li><li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引 B + 树。</li></ul><hr><p><strong>锁类型</strong></p><ul><li>共享锁 (S 锁): 假设事务 T1 对数据 A 加上共享锁，那么事务 T2 可以读数据 A，不能修改数据 A。</li><li>排他锁 (X 锁): 假设事务 T1 对数据 A 加上排他锁 ，那么事务 T2 不能读数据 A，不能修改数据 A。<br>我们通过 update、delete 等语句加上的锁都是行级别的锁。只有 LOCK TABLE … READ 和 LOCK TABLE … WRITE 才能申请表级别的锁。</li><li>意向共享锁 (IS 锁): 一个事务在获取（任何一行 / 或者全表）S 锁之前，一定会先在所在的表上加 IS 锁。</li><li>意向排他锁 (IX 锁): 一个事务在获取（任何一行 / 或者全表）X 锁之前，一定会先在所在的表上加 IX 锁。</li></ul><blockquote><p>意向锁存在的目的?</p></blockquote><p>这里说一下意向锁存在的目的。假设事务 T1，用 X 锁来锁住了表上的几条记录，那么此时表上存在 IX 锁，即意向排他锁。那么此时事务 T2 要进行 LOCK TABLE … WRITE 的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p><ul><li>Record Locks：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，InnoDB 一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！</li><li>Gap Locks：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在 <code>Read Committed</code> 隔离级别下，不会使用间隙锁。</li></ul><blockquote><p>这里我对官网补充一下，隔离级别比 Read Committed 低的情况下，也不会使用间隙锁，如隔离级别为 Read Uncommited 时，也不存在间隙锁。当隔离级别为 Repeatable Read 和 Serializable 时，就会存在间隙锁。</p></blockquote><ul><li>Next-Key Locks：这个理解为 Record Lock + 索引前面的 Gap Lock。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13 和 20。那么，间隙锁的范围如下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">(negative infinity, <span class="hljs-number">10</span>]<br>(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]<br>(<span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br>(<span class="hljs-number">13</span>, <span class="hljs-number">20</span>]<br>(<span class="hljs-number">20</span>, positive infinity)<br></code></pre></td></tr></table></figure><hr><p><strong>索引原理介绍</strong></p><p>先来一张带主键的表，如下所示，pId 是主键</p><table><thead><tr><th>pId</th><th>name</th><th>birthday</th></tr></thead><tbody><tr><td>5</td><td>zhangsan</td><td>2016-10-02</td></tr><tr><td>8</td><td>lisi</td><td>2015-10-04</td></tr><tr><td>11</td><td>wangwu</td><td>2016-09-02</td></tr><tr><td>13</td><td>zhaoliu</td><td>2015-10-07</td></tr></tbody></table><p>画出该表的结构图如下</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108763.png" srcset="/img/loading.gif" lazyload alt></p><p>如上图所示，分为上下两个部分，上半部分是由主键形成的 B + 树，下半部分就是磁盘上真实的数据！那么，当我们， 执行下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> pId<span class="hljs-operator">=</span><span class="hljs-string">&#x27;11&#x27;</span><br></code></pre></td></tr></table></figure><p>那么，执行过程如下</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108128.png" srcset="/img/loading.gif" lazyload alt></p><p>如上图所示，从根开始，经过 3 次查找，就可以找到真实数据。如果不使用索引，那就要在磁盘上，进行逐行扫描，直到找到数据位置。显然，使用索引速度会快。但是在写入数据的时候，需要维护这颗 B + 树的结构，因此写入性能会下降！</p><hr><p><strong>聚簇索引、非聚簇索引</strong></p><ul><li>聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</li><li>非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</li></ul><p>在 InnoDB 中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong>。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108094.png" srcset="/img/loading.gif" lazyload alt></p><ol><li>InnoDB 使用的是聚簇索引，将主键组织到一棵 B + 树中，而行数据就储存在叶子节点上，若使用 “where id = 14” 这样的条件查找主键，则按照 B + 树的检索算法即可查找到对应的叶节点，之后获得行数据。</li><li>若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B + 树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B + 树种再执行一次 B + 树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</li></ol><p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p><p><strong>表中行的物理顺序和索引中行的物理顺序是相同的</strong>，<strong>在创建任何非聚簇索引之前创建聚簇索引</strong>，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p><p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一且非空的索引</strong>代替。如果没有这样的索引，InnoDB 会 <strong>隐式定义一个主键</strong>（类似 oracle 中的 RowId）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p><p>MyISAM 使用的是非聚簇索引，<strong>非聚簇索引的两棵 B + 树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引 B + 树的节点存储了主键，辅助键索引 B + 树存储了辅助键。表数据存储在独立的地方，这两颗 B + 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082108938.png" srcset="/img/loading.gif" lazyload alt></p><hr><p><strong>使用聚簇索引的优势：</strong></p><ul><li>每次使用辅助索引检索都要经过两次 B + 树查找， 看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？</li></ul><ol><li>由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了 Buffer 中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 Id 来组织数据，获得数据更快。</li><li>辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次 IO 读写的缓存中没有，需要发生一次新的 IO 操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</li></ol><blockquote><p>注：我们知道一次 io 读写，可以获取到 16K 大小的资源，我们称之为读取到的数据区域为 Page。而我们的 B 树，B + 树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次 IO 操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行 IO 操作了。除非发生了页的分裂，即要查询的行数据不在上次 IO 操作的换村里，才会触发新的 IO 操作。</p></blockquote><ol><li>因为 MyISAM 的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行 I/O 读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次 I/O。（强烈的对比）</li><li>不过，如果涉及到大数据量的排序、全表扫描、count 之类的操作的话，还是 MyISAM 占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</li></ol><p><strong>聚簇索引需要注意的地方</strong></p><p>当使用主键为聚簇索引时，主键最好不要使用 uuid，因为 uuid 的值太过离散，不适合排序且可能出线新增加记录的 uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</p><p>建议使用 int 类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到 IO 操作读取到的数据量。</p><p><strong>为什么主键通常建议使用自增 id</strong></p><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增 id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><hr><p><strong>四个隔离级别</strong></p><p>我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:</p><ul><li>Read Uncommited(RU)：读未提交，一个事务可以读到另一个事务未提交的数据！</li><li>Read Committed (RC)：读已提交，一个事务可以读到另一个事务已提交的数据!</li><li>Repeatable Read(RR): 可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免! 我会在下一篇文章说明! 另外就是记住从该级别才开始加入间隙锁 (这句话记下来，后面有用到)!</li><li>Serializable：串行化，该级别下读写串行化，且所有的 select 语句后都自动加上 lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。</li></ul><p><strong>select 分析的表数据</strong></p><p>为了便于说明，我来个例子，假设有表数据如下，pId 为主键索引</p><table><thead><tr><th>pId(int)</th><th>name(varchar)</th><th>num(int)</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>100</td></tr><tr><td>2</td><td>bbb</td><td>200</td></tr><tr><td>7</td><td>ccc</td><td>200</td></tr></tbody></table><p><strong>隔离级别：RC/RU ，条件列: 非索引</strong></p><p>(1)<code>select * from table where num = 200</code></p><p>不加任何锁，是快照读。</p><p>(2)<code>select * from table where num &gt; 200</code></p><p>不加任何锁，是快照读。</p><p>(3)<code>select * from table where num = 200 lock in share mode</code></p><p>当 num = 200，有两条记录。这两条记录对应的 pId=2，7，因此在 pId=2，7 的聚簇索引上加行级 S 锁，采用当前读。</p><p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p><p>当 num &gt; 200，有一条记录。这条记录对应的 pId=3，因此在 pId=3 的聚簇索引上加上行级 S 锁，采用当前读。</p><p>(5)<code>select * from table where num = 200 for update</code></p><p>当 num = 200，有两条记录。这两条记录对应的 pId=2，7，因此在 pId=2，7 的聚簇索引上加行级 X 锁，采用当前读。</p><p>(6)<code>select * from table where num &gt; 200 for update</code></p><p>当 num &gt; 200，有一条记录。这条记录对应的 pId=3，因此在 pId=3 的聚簇索引上加上行级 X 锁，采用当前读。</p><p><strong>隔离级别：RC/RU ，条件列: 聚簇索引</strong></p><p>大家应该知道 pId 是主键列，因此 pId 用的就是聚簇索引。此情况其实和 RC/RU + 条件列非索引情况是类似的。</p><p>(1)<code>select * from table where pId = 2</code></p><p>不加任何锁，是快照读。</p><p>(2)<code>select * from table where pId &gt; 2</code></p><p>不加任何锁，是快照读。</p><p>(3)<code>select * from table where pId = 2 lock in share mode</code></p><p>在 pId=2 的聚簇索引上，加 S 锁，为当前读。</p><p>(4)<code>select * from table where pId &gt; 2 lock in share mode</code></p><p>在 pId=3，7 的聚簇索引上，加 S 锁，为当前读。</p><p>(5)<code>select * from table where pId = 2 for update</code></p><p>在 pId=2 的聚簇索引上，加 X 锁，为当前读。</p><p>(6)<code>select * from table where pId &gt; 2 for update</code></p><p>在 pId=3，7 的聚簇索引上，加 X 锁，为当前读。</p><p>为什么条件列加不加索引，加锁情况是一样的？</p><blockquote><p>其实是不一样的。在 RC/RU 隔离级别中，MySQL 做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server 层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是 RC/RU + 条件列非索引比本例多了一个释放不符合条件的锁的过程！</p></blockquote><p><strong>隔离级别：RC/RU ，条件列: 非聚簇索引</strong></p><p>在 num 列上建上非唯一索引。此时有一棵聚簇索引 (主键索引，pId) 形成的 B + 索引树，其叶子节点为硬盘上的真实数据。以及另一棵非聚簇索引 (非唯一索引，num) 形成的 B + 索引树，其叶子节点依然为索引节点，保存了 num 列的字段值，和对应的聚簇索引。</p><p>(1)<code>select * from table where num = 200</code></p><p>不加任何锁，是快照读。</p><p>(2)<code>select * from table where num &gt; 200</code></p><p>不加任何锁，是快照读。</p><p>(3)<code>select * from table where num = 200 lock in share mode</code></p><p>当 num = 200，由于 num 列上有索引，因此先在 num = 200 的两条索引记录上加行级 S 锁。接着，去聚簇索引树上查询，这两条记录对应的 pId=2，7，因此在 pId=2，7 的聚簇索引上加行级 S 锁，采用当前读。</p><p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p><p>当 num &gt; 200，由于 num 列上有索引，因此先在符合条件的 num = 300 的一条索引记录上加行级 S 锁。接着，去聚簇索引树上查询，这条记录对应的 pId=3，因此在 pId=3 的聚簇索引上加行级 S 锁，采用当前读。</p><p>(5)<code>select * from table where num = 200 for update</code></p><p>当 num = 200，由于 num 列上有索引，因此先在 num = 200 的两条索引记录上加行级 X 锁。接着，去聚簇索引树上查询，这两条记录对应的 pId=2，7，因此在 pId=2，7 的聚簇索引上加行级 X 锁，采用当前读。</p><p>(6)<code>select * from table where num &gt; 200 for update</code></p><p>当 num &gt; 200，由于 num 列上有索引，因此先在符合条件的 num = 300 的一条索引记录上加行级 X 锁。接着，去聚簇索引树上查询，这条记录对应的 pId=3，因此在 pId=3 的聚簇索引上加行级 X 锁，采用当前读。</p><hr><p><strong>隔离级别：RR/Serializable，条件列: 非索引</strong></p><p>RR 级别需要多考虑的就是 gap lock，他的加锁特征在于，无论你怎么查都是锁全表。接下来分析开始</p><p>(1)<code>select * from table where num = 200</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 <code>Serializable</code> 级别下，在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 S 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p>(2)<code>select * from table where num &gt; 200</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 <code>Serializable</code> 级别下，在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 S 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p>(3)<code>select * from table where num = 200 lock in share mode</code></p><p>在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 S 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p><p>在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 S 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p>(5)<code>select * from table where num = 200 for update</code></p><p>在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 X 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p>(6)<code>select * from table where num &gt; 200 for update</code></p><p>在 pId = 1,2,3,7（全表所有记录）的聚簇索引上加 X 锁。并且在聚簇索引的所有间隙 (-∞,1)(1,2)(2,3)(3,7)(7,+∞) 加 gap lock</p><p><strong>隔离级别：RR/Serializable，条件列: 聚簇索引</strong></p><p>大家应该知道 pId 是主键列，因此 pId 用的就是聚簇索引。该情况的加锁特征在于，如果 where 后的条件为精确查询 (= 的情况)，那么只存在 record lock。如果 where 后的条件为范围查询(&gt; 或&lt;的情况)，那么存在的是 record lock+gap lock。</p><p>(1)<code>select * from table where pId = 2</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 Serializable 级别下，是当前读，在 pId=2 的聚簇索引上加 S 锁，不存在 gap lock。</p><p>(2)<code>select * from table where pId &gt; 2</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 <code>Serializable</code> 级别下，是当前读，在 pId=3,7 的聚簇索引上加 S 锁。在 (2,3)(3,7)(7,+∞) 加上 gap lock</p><p>(3)<code>select * from table where pId = 2 lock in share mode</code></p><p>是当前读，在 pId=2 的聚簇索引上加 S 锁，不存在 gap lock。</p><p>(4)<code>select * from table where pId &gt; 2 lock in share mode</code></p><p>是当前读，在 pId=3,7 的聚簇索引上加 S 锁。在 (2,3)(3,7)(7,+∞) 加上 gap lock</p><p>(5)<code>select * from table where pId = 2 for update</code></p><p>是当前读，在 pId=2 的聚簇索引上加 X 锁。</p><p>(6)<code>select * from table where pId &gt; 2 for update</code></p><p>在 pId=3,7 的聚簇索引上加 X 锁。在 (2,3)(3,7)(7,+∞) 加上 gap lock</p><p>(7)<code>select * from table where pId = 6 [lock in share mode|for update]</code></p><p>注意了，pId=6 是不存在的列，这种情况会在 (3,7) 上加 gap lock。</p><p>(8)<code>select * from table where pId &gt; 18 [lock in share mode|for update]</code></p><p>注意了，pId&gt;18，查询结果是空的。在这种情况下，是在 (7,+∞) 上加 gap lock。</p><p><strong>隔离级别：RR/Serializable，条件列: 非聚簇索引</strong></p><p>这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。</p><p>先说一下，唯一索引的情况。如果是唯一索引，情况和 RR/Serializable + 条件列是聚簇索引类似，唯一有区别的是: 这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！大家可以自行推敲!</p><p>下面说一下，非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在 record lock，还存在 gap lock。而通过唯一索引进行精确查询后，只存在 record lock，不存在 gap lock。老规矩在 num 列建立非唯一索引</p><p>(1)<code>select * from table where num = 200</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 <code>Serializable</code> 级别下，是当前读，在 pId=2，7 的聚簇索引上加 S 锁，在 num=200 的非聚集索引上加 S 锁，在 (100,200)(200,300) 加上 gap lock。</p><p>(2)<code>select * from table where num &gt; 200</code></p><p>在 RR 级别下，不加任何锁，是快照读。</p><p>在 <code>Serializable</code> 级别下，是当前读，在 pId=3 的聚簇索引上加 S 锁，在 num=300 的非聚集索引上加 S 锁。在 (200,300)(300,+∞) 加上 gap lock</p><p>(3)<code>select * from table where num = 200 lock in share mode</code></p><p>是当前读，在 pId=2，7 的聚簇索引上加 S 锁，在 num=200 的非聚集索引上加 S 锁，在 (100,200)(200,300) 加上 gap lock。</p><p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p><p>是当前读，在 pId=3 的聚簇索引上加 S 锁，在 num=300 的非聚集索引上加 S 锁。在 (200,300)(300,+∞) 加上 gap lock。</p><p>(5)<code>select * from table where num = 200 for update</code></p><p>是当前读，在 pId=2，7 的聚簇索引上加 S 锁，在 num=200 的非聚集索引上加 X 锁，在 (100,200)(200,300) 加上 gap lock。</p><p>(6)<code>select * from table where num &gt; 200 for update</code></p><p>是当前读，在 pId=3 的聚簇索引上加 S 锁，在 num=300 的非聚集索引上加 X 锁。在 (200,300)(300,+∞) 加上 gap lock</p><p>(7)<code>select * from table where num = 250 [lock in share mode|for update]</code></p><p>注意了，num=250 是不存在的列，这种情况会在 (200,300) 上加 gap lock。</p><p>(8)<code>select * from table where num &gt; 400 [lock in share mode|for update]</code></p><p>注意了，pId&gt;400，查询结果是空的。在这种情况下，是在 (400,+∞) 上加 gap lock。</p><hr><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><p>MyISAM 表锁是 deadlock free 的，这是因为 MyISAM 总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。</p><p><strong>如何避免死锁？</strong></p><ul><li>为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 <code>SELECT … FOR UPDATE</code> 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的；</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁；</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会；</li><li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</li><li>在 <code>REPEATABLE-READ</code> 隔离级别下，如果两个线程同时对相同条件记录用 <code>SELECT…FOR UPDATE</code> 加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成 <code>READ COMMITTED</code>，就可避免问题；</li><li>当隔离级别为 <code>READ COMMITTED</code> 时，如果两个线程都先执行 <code>SELECT…FOR UPDATE</code>，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第 1 个线程提交后，第 2 个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第 3 个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行 ROLLBACK 释放获得的排他锁</li></ul><hr><p><strong>InnoDB 默认是如何对待死锁的？</strong></p><p>InnoDB 默认是使用设置死锁时间来让死锁超时的策略，默认 innodb_lock_wait_timeout 设置的时长是 50s。</p><p><strong>如何开启死锁检测？</strong></p><p>设置 innodb_deadlock_detect 设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。</p><h2 id="解决方案-2乐观锁"><a class="markdownIt-Anchor" href="#解决方案-2乐观锁"></a> 解决方案 2：乐观锁</h2><h3 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h3><p>乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新。类似如下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_sku <span class="hljs-keyword">set</span> stock<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> stock<span class="hljs-operator">=</span><span class="hljs-number">7</span>;<br>SKU.objects.filter(id<span class="hljs-operator">=</span><span class="hljs-number">1</span>, stock<span class="hljs-operator">=</span><span class="hljs-number">7</span>).<span class="hljs-keyword">update</span>(stock<span class="hljs-operator">=</span><span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="使用乐观锁需修改数据库的事务隔离级别"><a class="markdownIt-Anchor" href="#使用乐观锁需修改数据库的事务隔离级别"></a> <strong>使用乐观锁需修改数据库的事务隔离级别</strong></h3><p>使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用<strong>可重复读的隔离级别</strong>，应该修改为读取已提交（Read committed）。</p><p>修改方式：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109519.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109293.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="mysql-事务隔离级别"><a class="markdownIt-Anchor" href="#mysql-事务隔离级别"></a> <strong>MySQL 事务隔离级别</strong></h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>mysql 默认的事务隔离级别为 repeatable-read</strong></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109798.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="并发事务会带来哪些问题"><a class="markdownIt-Anchor" href="#并发事务会带来哪些问题"></a> 并发事务会带来哪些问题？</h3><p>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p><p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果<strong>不一致</strong>。</p><p>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h3 id="用例子说明各个隔离级别的情况"><a class="markdownIt-Anchor" href="#用例子说明各个隔离级别的情况"></a> <strong>用例子说明各个隔离级别的情况</strong></h3><p><strong>1、读未提交：</strong></p><p>（1）打开一个客户端 A，并设置当前事务模式为 read uncommitted（未提交读），查询表 account 的初始值：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109991.png" srcset="/img/loading.gif" lazyload alt></p><p>（2）在客户端 A 的事务提交之前，打开另一个客户端 B，更新表 account：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082109708.png" srcset="/img/loading.gif" lazyload alt></p><p>（3）这时，虽然客户端 B 的事务还没提交，但是客户端 A 就可以查询到 B 已经更新的数据：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110346.png" srcset="/img/loading.gif" lazyload alt></p><p>（4）一旦客户端 B 的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端 A 查询到的数据其实就是脏数据：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110049.png" srcset="/img/loading.gif" lazyload alt></p><p>（5）在客户端 A 执行更新语句 <code>update account set balance = balance - 50 where id =1</code>，lilei 的 balance 没有变成 350，居然是 400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用 400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110480.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>2、读已提交</strong></p><p>（1）打开一个客户端 A，并设置当前事务模式为 read committed（提交读），查询表 account 的所有记录：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082110147.png" srcset="/img/loading.gif" lazyload alt></p><p>（2）在客户端 A 的事务提交之前，打开另一个客户端 B，更新表 account：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111033.png" srcset="/img/loading.gif" lazyload alt></p><p>（3）这时，客户端 B 的事务还没提交，客户端 A 不能查询到 B 已经更新的数据，解决了脏读问题：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111382.png" srcset="/img/loading.gif" lazyload alt></p><p>（4）客户端 B 的事务提交</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111077.png" srcset="/img/loading.gif" lazyload alt></p><p>（5）客户端 A 执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082111732.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>3、可重复读</strong></p><p>（1）打开一个客户端 A，并设置当前事务模式为 repeatable read，查询表 account 的所有记录。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082112097.png" srcset="/img/loading.gif" lazyload alt></p><p>（2）在客户端 A 的事务提交之前，打开另一个客户端 B，更新表 account 并提交。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113621.png" srcset="/img/loading.gif" lazyload alt></p><p>（3）在客户端 A 查询表 account 的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113836.png" srcset="/img/loading.gif" lazyload alt></p><p>（4）在客户端 A，接着执行 update balance = balance - 50 where id = 1，balance 没有变成 400-50=350，lilei 的 balance 值用的是步骤（2）中的 350 来算的，所以是 300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了 MVCC 机制，select 操作不会更新版本号，是快照读（历史版本）；insert、update 和 delete 会更新版本号，是当前读（当前版本）。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082113733.png" srcset="/img/loading.gif" lazyload alt></p><p>（5）重新打开客户端 B，插入一条新数据后提交。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082114910.png" srcset="/img/loading.gif" lazyload alt></p><p>（6）在客户端 A 查询表 account 的所有记录，没有 查出 新增数据，所以没有出现幻读。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082114407.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>4. 串行化</strong></p><p>（1）打开一个客户端 A，并设置当前事务模式为 serializable，查询表 account 的初始值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> session transaction isolation level serializable;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> transaction;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account;<br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name   <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------+</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span> lilei  <span class="hljs-operator">|</span>   <span class="hljs-number">10000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> hanmei <span class="hljs-operator">|</span>   <span class="hljs-number">10000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> lucy   <span class="hljs-operator">|</span>   <span class="hljs-number">10000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span> lily   <span class="hljs-operator">|</span>   <span class="hljs-number">10000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>（2）打开一个客户端 B，并设置当前事务模式为 serializable，插入一条记录报错，表被锁了插入失败，mysql 中事务隔离级别为 serializable 时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> session transaction isolation level serializable;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> transaction;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">0</span>);<br>ERROR <span class="hljs-number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction<br></code></pre></td></tr></table></figure><p>补充：</p><p>1、事务隔离级别为读提交时，写数据只会锁住相应的行。</p><p>2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是 next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</p><p>3、事务隔离级别为串行化时，读写数据都会锁住整张表。</p><p>4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p><h3 id="乐观锁在高并发场景下的问题"><a class="markdownIt-Anchor" href="#乐观锁在高并发场景下的问题"></a> 乐观锁在高并发场景下的问题</h3><p>乐观锁在高并发场景下的问题，是严重的空自旋。</p><p>具体可以参考 入大厂必备的基础书籍： 《Java 高并发核心编程 卷 2》</p><h2 id="超卖解决方案-3分阶段排队下单方案"><a class="markdownIt-Anchor" href="#超卖解决方案-3分阶段排队下单方案"></a> 超卖解决方案 3：分阶段排队下单方案</h2><h3 id="分阶段排队下单方案的思想来源"><a class="markdownIt-Anchor" href="#分阶段排队下单方案的思想来源"></a> 分阶段排队下单方案的思想来源</h3><p>最优的解决方案，其实思想来自于 JUC 的原理</p><blockquote><p>JUC 是如何提高性能的，引入队列</p></blockquote><p><strong>原始的 CLH 队列</strong></p><p>用于减少线程争用的最简单的队列，CLH 队列，具体可以参考 入大厂必备的基础书籍： 《Java 高并发核心编程 卷 2》</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115036.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>JUC 的 AQS 内部队列</strong></p><p>AQS 内部队列是 JUC 高性能的基础，AQS 队列，具体可以参考 入大厂必备的基础书籍： 《Java 高并发核心编程 卷 2》</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115140.png" srcset="/img/loading.gif" lazyload alt></p><hr><h3 id="分阶段排队下单方案"><a class="markdownIt-Anchor" href="#分阶段排队下单方案"></a> 分阶段排队下单方案</h3><p>将提交操作变成两段式：</p><ul><li>第一阶段申请，申请预减减库，申请成功之后，进入消息队列；</li><li>第二阶段确认，从消息队列消费申请令牌，然后完成下单操作。 查库存 -&gt; 创建订单 -&gt; 扣减库存。通过分布式锁保障解决多个 provider 实例并发下单产生的超卖问题。</li></ul><p><strong>申请阶段</strong></p><p>将存库从 MySQL 前移到 Redis 中，所有的预减库存的操作放到内存中，由于 Redis 中不存在锁故不会出现互相等待，并且由于 Redis 的写性能和读性能都远高于 MySQL，这就解决了高并发下的性能问题。</p><p><strong>确认阶段</strong></p><p>然后通过队列等异步手段，将变化的数据异步写入到 DB 中。</p><p>引入队列，然后数据通过队列排序，按照次序更新到 DB 中，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。</p><h3 id="分阶段排队架构图"><a class="markdownIt-Anchor" href="#分阶段排队架构图"></a> 分阶段排队架构图</h3><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082115901.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>基于分段的排队执行方案的性能提升</strong></p><p>一个高性能秒杀的场景：</p><blockquote><p>假设一个商品 1 分钟 6000 订单，每秒的 600 个下单操作。</p><p>在排队阶段，每秒的 600 个预减库存的操作，对于 Redis 来说，没有任何压力。甚至每秒的 6000 个预减库存的操作，对于 Redis 来说，也是压力不大。</p><p>但是在下单阶段，就不一样了。假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，经过优化，每个 IO 操作 100ms，大概 200 毫秒，一秒钟 5 个订单。600 个订单需要 120s，2 分钟才能彻底消化。</p></blockquote><p>如何提升下单阶段的性能呢？</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082116508.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>可以使用 Redis 分段锁。</strong></p><p>为了达到每秒 600 个订单，可以将锁分成 600 /5 =120 个段，每个段负责 5 个订单，600 个订单，在第二个阶段 1 秒钟下单完成。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405082118654.png" srcset="/img/loading.gif" lazyload alt></p><p>有关 Redis 分段锁的详细知识，请阅读下面的博文：</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/14731826.html">Redis 分布式锁 （图解 - 秒懂 - 史上最全）</a></p><p><strong>基于分段的排队执行方案优点</strong></p><p>解决超卖问题，库存读写都在内存中，故同时解决性能问题。</p><p><strong>基于分段的排队执行方案缺点</strong></p><ul><li>数据不一致的问题：</li></ul><p>由于异步写入 DB，可能存在数据不一致，存在某一时刻 DB 和 Redis 中数据不一致的风险。</p><ul><li>可能存在少买</li></ul><p>可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为 0，但是订单数并没有达到库存阀值。</p><blockquote><p>参考文献：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9950951.html">https://www.cnblogs.com/rjzheng/p/9950951.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/caoxiaohong1005/article/details/78292457">https://blog.csdn.net/caoxiaohong1005/article/details/78292457</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyaokai/p/10921323.html">https://www.cnblogs.com/wyaokai/p/10921323.html</a></p></blockquote></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>超卖问题（图解 + 秒懂 + 史上最全）</div><div>https://fulequn.github.io/2024/05/Article202405081/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年5月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/05/Article202405101/" title="算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第一部分</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/05/Article202405072/" title="超卖问题-多位骑手抢一个外卖订单，如何保证只有一个骑手可以接到单子？"><span class="hidden-mobile">超卖问题-多位骑手抢一个外卖订单，如何保证只有一个骑手可以接到单子？</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>