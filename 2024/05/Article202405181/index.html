<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：  F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1  给定 n ，请计算 F(n) 。 示例 1：  输入：n &#x3D; 2 输出：1 解释：F(2) &#x3D; F(1) + F(0) &#x3D;"><meta property="og:type" content="article"><meta property="og:title" content="算法训练3.2.1 基础DP"><meta property="og:url" content="https://fulequn.github.io/2024/05/Article202405181/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：  F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1  给定 n ，请计算 F(n) 。 示例 1：  输入：n &#x3D; 2 输出：1 解释：F(2) &#x3D; F(1) + F(0) &#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182151752.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182152946.gif"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182152529.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153084.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153939.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153862.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153069.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154994.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154669.gif"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154127.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154004.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154396.png"><meta property="og:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182155017.png"><meta property="article:published_time" content="2024-05-18T13:30:17.000Z"><meta property="article:modified_time" content="2024-05-30T00:16:58.000Z"><meta property="article:author" content="Fulequn"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182151752.png"><title>算法训练3.2.1 基础DP - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法训练3.2.1 基础DP"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-05-18 21:30" pubdate>2024年5月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>92 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">算法训练3.2.1 基础DP</h1><div class="markdown-body"><h3 id="斐波那契数"><a class="markdownIt-Anchor" href="#斐波那契数"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></h3><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p>示例 1：</p><blockquote><p>输入：n = 2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p></blockquote><p>示例 3：</p><blockquote><p>输入：n = 4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p></blockquote><blockquote><p>提示：<br>0 &lt;= n &lt;= 30</p></blockquote><p><strong>题目解析</strong></p><p>此题是动态规划最简单的题目之一。</p><ul><li><p>状态转移方程式：题目已经明确告诉我们，<code>F(n) = F(n - 1) + F(n - 2)</code></p></li><li><p>容器规模：数组表示的范围是 <code>[0, n]</code>，因此数组大小定义为<code>n+1</code></p></li><li><p>base case：对于任意的 <code>i</code>，都只依赖于 <code>i - 1</code> 和 <code>i - 2</code> ，因此我们只需要将数组下标为 <code>0</code> 和下标为 <code>1</code> 预先填好，后面所有的值都按照式子即可填满表中所有的值。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182151752.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：从下标为 <code>2</code> 开始往后填表即可</p></li></ul><p>过程如下：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182152946.gif" srcset="/img/loading.gif" lazyload alt></p><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ; i &lt;= n ; i++) dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍"><a class="markdownIt-Anchor" href="#打家劫舍"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><blockquote><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p></blockquote><p><strong>题目解析</strong></p><p>此题本质上是斐波那契数列。</p><ul><li>状态转移方程式：<code>dp[i]</code> 表示考虑 <code>[0, i]</code> 的子数组按照规则进行偷窃，能获取的最大价值。对于下标为 <code>i</code> 的元素，可以选和不选，如果选的话则只能考虑 <code>i - 2</code>（因为不能偷相邻的），否则则考虑 <code>i - 1</code>，因此式子为：<code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code></li><li>容器规模：<code>i</code> 的含义是数组下标，因此范围是 <code>[0, nums.length - 1]</code>，因此容器大小是 <code>nums.length</code></li><li>base case：对于任意一个元素 <code>i</code> 只依赖 <code>i - 1</code> 和 <code>i - 2</code>，因此只需要预先填上 <code>nums[0]</code> 和 <code>nums[1]</code> 即可。</li><li>填表顺序：从下标为 <code>2</code> 开始按序填满数组即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算能够偷到的最大金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 表示每个房屋存放的金额的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 偷到的最大金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 如果只有一个房屋，则直接返回该房屋存放的金额</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 初始化动态规划数组，dp[i] 表示偷到第 i 个房屋时能够得到的最大金额</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 初始化动态规划数组的前两个元素</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从第三个房屋开始遍历，计算每个房屋能够得到的最大金额</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ; i &lt; nums.length ; i++) <br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]); <span class="hljs-comment">// 状态转移方程</span><br>        <span class="hljs-comment">// 返回最后一个房屋能够得到的最大金额</span><br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小路径和"><a class="markdownIt-Anchor" href="#最小路径和"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明</strong>：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182152529.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>示例 2：</p><blockquote><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p></blockquote><blockquote><p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 200<br>0 &lt;= grid[i][j] &lt;= 100</p></blockquote><p><strong>题目解析</strong></p><ul><li><p>状态转移方程式：<code>dp[i][j]</code> 表示走到 <code>(i, j)</code> 这个位置的最小路径和的值。而走到位置 <code>(i, j)</code> 只有两个位置可以走过来，也就是 <code>(i - 1, j)</code> 和 <code>(i, j - 1)</code>，因此我们取最小的即可，也就是 <code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code></p></li><li><p>容器规模：<code>i</code> 和 <code>j</code> 的范围分别是 <code>m</code> 和 <code>n</code> ，因此定义 <code>dp[m][n]</code> 即可</p></li><li><p>base case：对于任意一个位置 <code>(i, j)</code> 都依赖于 <code>(i - 1, j)</code> 和 <code>(i, j - 1)</code>。因此我们只需要填满第一行 <code>f(0, j)</code> 即可，接下来依次填满填满即可 <code>(f(1, j), f(2, j))</code>。有一定基础的同学不难看出，这个依赖关系与“完全背包”一致。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153084.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：从 <code>i</code> 等于 <code>1</code> 开始，一行一行从左往右填表即可。</p></li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算从左上角到右下角的最小路径和</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> grid 表示网格的二维数组，grid[i][j] 表示第 i 行第 j 列的格子上的数字</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 最小路径和</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 获取网格的行数和列数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 计算第一行每个格子的最小路径和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; n ; i++) <br>            grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 每个格子的路径和等于当前格子的值加上左边格子的路径和</span><br>        <span class="hljs-comment">// 计算第一列每个格子的最小路径和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; m ; i++) <br>            grid[i][<span class="hljs-number">0</span>] += grid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 每个格子的路径和等于当前格子的值加上上方格子的路径和</span><br>        <span class="hljs-comment">// 计算其他格子的最小路径和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; m ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt; n ; j++) <br>                grid[i][j] += Math.min(grid[i - <span class="hljs-number">1</span>][j], grid[i][j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 每个格子的路径和等于当前格子的值加上上方格子和左边格子中的较小路径和</span><br>        &#125;<br>        <span class="hljs-comment">// 返回右下角格子的最小路径和</span><br>        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径"><a class="markdownIt-Anchor" href="#不同路径"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153939.png" srcset="/img/loading.gif" lazyload alt="示例1"></p><blockquote><p>输入：m = 3, n = 7<br>输出：28</p></blockquote><p>示例 2：</p><blockquote><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。<br>1.向右 -&gt; 向下 -&gt; 向下<br>2.向下 -&gt; 向下 -&gt; 向右<br>3.向下 -&gt; 向右 -&gt; 向下</p></blockquote><p>示例 3：</p><blockquote><p>输入：m = 7, n = 3<br>输出：28</p></blockquote><p>示例 4：</p><blockquote><p>输入：m = 3, n = 3<br>输出：6</p></blockquote><blockquote><p>提示：<br>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10^9</p></blockquote><p><strong>题目解析</strong></p><ul><li><p>状态转移方程式：<code>dp[i][j]</code> 表示走到位置 <code>(i, j)</code> 有多少种走法。走到位置 <code>(i, j)</code> 只有两个方向 <code>(i - 1, j)</code> 和 <code>(i, j - 1)</code></p></li><li><p>容器规模：<code>i</code> 和 <code>j</code> 的范围分别是 <code>[0, m - 1]</code> 和 <code>[0, n - 1]</code>，因此 <code>dp[m][n]</code></p></li><li><p>base case：对于任意位置 <code>(i, j)</code> 都依赖于 <code>(i - 1, j)</code> 和 <code>(i, j -1)</code>，因此我们只需要填满第一行f(0, j)即可，接下来依次填满填满即可 <code>(f(1, j), f(2, j) … f(m - 1, j))</code>。有一定基础的同学不难看出，这个依赖关系与“完全背包”一致。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153862.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：从i等于1开始，一行一行从左往右填表即可。</p></li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// uniquePaths 方法用于计算在 m 行 n 列的网格中，从左上角到右下角的路径数量</span><br>    <span class="hljs-comment">// 只能向下或向右移动</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个 m 行 n 列的动态规划数组 dp，所有元素初始化为 0</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">// 对于第一行的每个位置，由于只能从左边到达，因此路径数量初始化为 1</span><br>        Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>); <span class="hljs-comment">// base case</span><br>        <br>        <span class="hljs-comment">// 遍历动态规划数组，填充路径数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-comment">// 对于第一列，由于只能从上面到达，因此路径数量等于上一行的路径数量</span><br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 遍历动态规划数组的当前行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 对于当前位置 dp[i][j]，其路径数量等于左边位置 dp[i][j - 1] 和上面位置 dp[i - 1][j] 的路径数量之和</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回到达右下角的路径数量，即 dp[m - 1][n - 1]</span><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径-ii"><a class="markdownIt-Anchor" href="#不同路径-ii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182153069.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>1.向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>2.向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p></blockquote><p>示例 2：</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154994.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1</p></blockquote><blockquote><p>提示：<br>m == obstacleGrid.length<br>n == obstacleGrid[i].length<br>1 &lt;= m, n &lt;= 100<br>obstacleGrid[i][j] 为 0 或 1</p></blockquote><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// uniquePathsWithObstacles 方法用于计算在包含障碍物的网格中，从左上角到右下角的路径数量</span><br>    <span class="hljs-comment">// 障碍物由 1 表示，空地由 0 表示，只能向下或向右移动</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-comment">// 获取网格的行数 m 和列数 n</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-comment">// 初始化一个 m 行 n 列的动态规划数组 dp，所有元素初始化为 0</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <br>        <span class="hljs-comment">// 遍历 dp 数组的第一行，如果遇到障碍物（obstacleGrid[0][j] == 1），则终止遍历</span><br>        <span class="hljs-comment">// 如果没有障碍物，则将 dp[0][j] 设置为 1，因为只能从左边到达</span><br>        Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 遍历 dp 数组，从第二行开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-comment">// 对于每一行，先假设列索引为 0 的位置的路径数量为 0，因为第一行已经初始化</span><br>            dp[i][<span class="hljs-number">0</span>] = obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <br>            <span class="hljs-comment">// 遍历当前行的每个位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 如果当前位置没有障碍物，则当前位置的路径数量是从上方和左方到达的路径数量之和</span><br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                        dp[i][j] += dp[i][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果当前位置有障碍物，则当前位置的路径数量为 0</span><br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回到达右下角的路径数量，即 dp[m - 1][n - 1]</span><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="杨辉三角"><a class="markdownIt-Anchor" href="#杨辉三角"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">杨辉三角</a></h3><p>给定一个非负整数 <code>numRows</code>，生成「杨辉三角」的前 <code>numRows</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154669.gif" srcset="/img/loading.gif" lazyload alt></p><p>示例 1:</p><blockquote><p>输入: numRows = 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p></blockquote><p>示例 2:</p><blockquote><p>输入: numRows = 1<br>输出: [[1]]</p></blockquote><blockquote><p>提示:<br>1 &lt;= numRows &lt;= 30</p></blockquote><p><strong>题目解析</strong></p><ul><li>状态转移方程式：<code>dp[i][j]</code> 表示位置 <code>i</code> 和 <code>j</code> 的值。<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</code></li><li>容器规模：第 <code>i</code> 层是一个长度为 <code>i</code> 的数组。</li><li>base case：任意一个位置 <code>(i, j)</code> 都依赖于 <code>(i - 1, j)</code> 和 <code>(i, j -1)</code>，因此只需要填满第一行即可。</li><li>填表顺序：一行一行填即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// generate 方法用于生成一个包含 numRows 行的杨辉三角</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-comment">// 初始化结果列表 res，使用 LinkedList 来存储杨辉三角的每一行</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 添加杨辉三角的第一行，只有一个元素 1</span><br>        res.add(Arrays.asList(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 从第二行开始循环，直到生成 numRows 行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-comment">// 初始化当前行的列表 cur，使用 LinkedList 来存储当前行的数字</span><br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 循环生成当前行的每个数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-comment">// 如果是当前行的第一个或最后一个数字，值为 1</span><br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == i) &#123;<br>                    cur.add(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 否则，当前数字是上一行相邻两个数字的和</span><br>                    <span class="hljs-comment">// 通过 res.get(i - 1).get(j) 和 res.get(i - 1).get(j - 1) 获取上一行的相邻数字</span><br>                    cur.add(res.get(i - <span class="hljs-number">1</span>).get(j) + res.get(i - <span class="hljs-number">1</span>).get(j - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将当前行添加到结果列表 res 中</span><br>            res.add(cur);<br>        &#125;<br>        <span class="hljs-comment">// 返回生成的杨辉三角</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三角形最小路径和"><a class="markdownIt-Anchor" href="#三角形最小路径和"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/">三角形最小路径和</a></h3><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p>示例 1：</p><blockquote><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11</p></blockquote><p>解释：如下面简图所示：</p><blockquote><p>2</p><p>3 4</p><p>6 5 7</p><p>4 1 8 3</p></blockquote><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>示例 2：</p><blockquote><p>输入：triangle = [[-10]]<br>输出：-10</p></blockquote><blockquote><p>提示：<br>1 &lt;= triangle.length &lt;= 200</p><p>triangle[0].length == 1</p><p>triangle[i].length == triangle[i - 1].length + 1</p><p>-10^4 &lt;= triangle[i][j] &lt;= 10^4</p></blockquote><p><strong>题目解析</strong></p><p>此题与杨辉三角一致。</p><ul><li>状态转移方程式：<code>dp[i][j]</code> 表示走到位置 <code>(i, j)</code> 的最小路径和。因此 <code>dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]</code></li><li>容器规模：第 <code>i</code> 层是一个长度为 <code>i</code> 的数组。</li><li>base case：任意一个位置 <code>(i, j)</code> 都依赖于 <code>(i - 1, j)</code> 和 <code>(i, j - 1)</code>，因此只需要填满第一行即可。</li><li>填表顺序：一行一行填即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// minimumTotal 方法用于计算从三角形顶部到底部的最小路径和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-comment">// 获取三角形的行数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-comment">// 如果三角形只有一行，则直接返回第一行的第一个元素作为结果</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 初始化一个二维数组 dp，用于存储动态规划的中间结果</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-comment">// 将三角形顶部的元素值赋给 dp 第一行的第一个元素</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 初始化答案 ans 为一个足够大的数，用于记录遍历过程中的最小路径和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000010</span>;<br>        <br>        <span class="hljs-comment">// 从三角形的第二行开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 对于每一行，遍历该行的每个元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-comment">// 将当前元素的值赋给 dp[i][j]</span><br>                dp[i][j] = triangle.get(i).get(j);<br>                <span class="hljs-comment">// 如果当前元素是行的第一个元素，则其路径和为 dp[i - 1][j] 加上当前元素的值</span><br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">// 如果当前元素是行的最后一个元素，则其路径和为 dp[i - 1][j - 1] 加上当前元素的值</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i) &#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果当前元素既不是行的第一个元素，也不是行的最后一个元素，</span><br>                    <span class="hljs-comment">// 则其路径和为当前元素的值加上上一行相邻两个元素路径和的较小值</span><br>                    dp[i][j] += Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-comment">// 如果当前已经到达三角形的最后一行，则更新答案 ans 为当前行的最小路径和</span><br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>) &#123;<br>                    ans = Math.min(ans, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回三角形的最小路径和</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全平方数"><a class="markdownIt-Anchor" href="#完全平方数"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h3><p>给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p>示例 1：</p><blockquote><p>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 13<br>输出：2<br>解释：13 = 4 + 9</p></blockquote><blockquote><p>提示：<br>1 &lt;= n &lt;= 10^4</p></blockquote><p><strong>题目描述</strong></p><ul><li>状态转移方程式：<code>dp[i]</code> 的含义为 <code>i</code> 的完全平方数的最少数量。枚举思路是把 <code>[1, i]</code> 的每个数字都尝试一次。也就是 <code>dp[i] = min(dp[i - j^2] + 1)</code>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><msqrt><mi>i</mi></msqrt><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [1,\sqrt{i}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.16476em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.91476em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:.833em"><span class="mord mathnormal">i</span></span></span><span style="top:-2.87476em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.12524000000000002em"><span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li>容器规模：<code>i</code> 的范围是 <code>[0, n]</code>，因此 dp[n + 1]</li><li>base case：<code>dp[1] = 1</code>，<code>i</code> 的完全平方数的数量是 <code>1</code></li><li>填表顺序，从 <code>2</code> 开始往后填即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// numSquares 方法用于计算将整数 n 表示为恰好几个完全平方数之和的最少数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个长度为 n + 1 的数组 dp，用于存储动态规划的中间结果</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 将 dp[1] 初始化为 1，因为 1 本身就是一个完全平方数</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 从 2 到 n 遍历所有整数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 计算 i 的平方根，用于后续循环中判断是否可以表示为某个完全平方数之和</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sqrt</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(i);<br>            <span class="hljs-comment">// 初始化 dp[i] 为一个足够大的数，确保后续可以找到更小的值</span><br>            dp[i] = <span class="hljs-number">10001</span>;<br>            <br>            <span class="hljs-comment">// 从 1 到 sqrt 遍历所有可能的完全平方数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= sqrt; j++) &#123;<br>                <span class="hljs-comment">// 更新 dp[i] 为 dp[i - j * j] + 1 和当前 dp[i] 的较小值</span><br>                <span class="hljs-comment">// dp[i - j * j] 表示 i 减去 j 的平方后的值对应的完全平方数个数加 1</span><br>                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回 dp[n]，即为 n 表示为完全平方数之和的最少数量</span><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和-iv"><a class="markdownIt-Anchor" href="#组合总和-iv"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [9], target = 3<br>输出：0</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums.length &lt;= 200</p><p>1 &lt;= nums[i] &lt;= 1000</p><p>nums 中的所有元素 <strong>互不相同</strong></p><p>1 &lt;= target &lt;= 1000</p></blockquote><p><strong>题目描述</strong></p><p>此题的枚举思路如下：</p><p>以样例1为例：对于数字7，我们可以选择1、2或者3，不同的选择最后求和的即可。</p><ul><li>状态转移方程式：<code>dp[i]</code> 表示用 <code>nums</code> 组成 <code>i</code> 有多少种组合方式。<code>dp[i] = Σ(dp[i - num])</code> 其中 <code>num∈nums</code>。</li><li>容器规模：<code>i</code> 的范围是 <code>[0, n]</code>。</li><li>base case：<code>dp[0] = 1</code>，0 的组合就只有一种（什么都不选）</li><li>顺序：从 1 到 n 填表</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// combinationSum4 方法用于找出所有和为 target 的不同组合的数量</span><br>    <span class="hljs-comment">// nums 是一个升序排列的整数数组，从中选出一些数字，使得它们的和为 target</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 获取数组 nums 的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 初始化一个大小为 target + 1 的 dp 数组，用于存储动态规划的中间结果</span><br>        <span class="hljs-comment">// dp[i] 表示和为 i 的组合数量</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 根据题目，和为 0 的组合只有一种，即空集，因此初始化 dp[0] 为 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历 dp 数组，从 1 到 target</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= target; i++) &#123;<br>            <span class="hljs-comment">// 遍历数组 nums</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-comment">// 对于 dp[i]，我们需要检查每个 num 是否可以从 i 中减去</span><br>                <span class="hljs-comment">// 如果 i 大于等于 num，则说明 num 可以作为和为 i 的一部分</span><br>                <span class="hljs-comment">// 因此，dp[i] 应该加上 dp[i - num]，即和为 i - num 的组合数量</span><br>                <span class="hljs-keyword">if</span> (i &gt;= num) &#123;<br>                    dp[i] += dp[i - num];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回 dp[target]，即和为 target 的不同组合的数量</span><br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a class="markdownIt-Anchor" href="#最长递增子序列"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的<strong>子序列</strong>。</p><p>示例 1：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums.length &lt;= 2500<br>10^4 &lt;= nums[i] &lt;= 10^4</p></blockquote><p><strong>题目解析</strong></p><ul><li>状态转移方程式：<code>dp[i]</code> 表示包含第 <code>i</code> 位的最长递增子序列的长度。因此 <code>dp[i] = max(dp[i], dp[j] + 1)</code>，其中 <code>j∈[0, i - 1]</code></li><li>容器规模：<code>i∈[0, length - 1]</code></li><li>base case：<code>dp</code> 数组全部赋值为 <code>1</code>（最少肯定是1）</li><li>顺序：从 <code>1</code> 开始往后填表即可</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// lengthOfLIS 方法用于计算数组 nums 中最长递增子序列的长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个 dp 数组，其长度与 nums 相同，所有元素初始值设为 1</span><br>        <span class="hljs-comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列的最大长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 初始化 ans 为 1，用于存储遍历过程中发现的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 外层循环从数组的第二个元素开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 内层循环从当前元素的前一个元素开始向前遍历</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-comment">// 如果当前元素 nums[i] 大于其前一个元素 nums[j]，则存在递增关系</span><br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    <span class="hljs-comment">// 更新 dp[i] 为 dp[j] + 1 和当前 dp[i] 的较大值</span><br>                    <span class="hljs-comment">// 表示以 nums[i] 结尾的最长递增子序列长度至少为 dp[j] + 1</span><br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// 更新 ans 为遍历过程中的最长递增子序列长度</span><br>                    ans = Math.max(ans, dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回 ans，即为数组 nums 中最长递增子序列的长度</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续递增序列"><a class="markdownIt-Anchor" href="#最长连续递增序列"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">最长连续递增序列</a></h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], …, nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums.length &lt;= 104<br>-10^9 &lt;= nums[i] &lt;= 10^9</p></blockquote><p>题目解析</p><ul><li>状态转移方程式：<code>dp[i]</code> 表示包含第 <code>i</code> 位的最长连续递增序列的长度。<code>if nums[i] &gt; nums[i - 1]: dp[i] = dp[i - 1] + 1</code></li><li>容器规模：<code>i∈[0, nums.length - 1]</code></li><li>base case：<code>dp</code> 数组全部赋值为 1</li><li>顺序：<code>i</code> 从 1 往后</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// findLengthOfLCIS方法用于找出最长递增子序列的长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// n表示数组nums的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// ans用于记录最长递增子序列的长度，初始值为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 创建一个长度为n的数组dp，用于存储到当前位置为止的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 将dp数组的所有元素初始化为1，因为每个元素至少是一个长度为1的递增子序列</span><br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 从数组的第二个元素开始遍历，因为单个元素的递增子序列长度为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; n ; i++) &#123;<br>            <span class="hljs-comment">// 如果当前元素nums[i]大于前一个元素nums[i-1]，则说明存在递增关系</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 更新dp[i]为dp[i-1]+1，即当前位置的最长递增子序列长度为前一个位置的递增子序列长度加1</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 更新ans为dp[i]和ans中的最大值，即记录到目前为止找到的最长递增子序列的长度</span><br>                ans = dp[i] &gt; ans ? dp[i] : ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长递增子序列的长度</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长重复子数组"><a class="markdownIt-Anchor" href="#最长重复子数组"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h3><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 两个数组中 <strong>公共的 、长度最长</strong>的子数组的长度 。</p><p>示例 1：</p><blockquote><p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br>输出：5</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums1.length, nums2.length &lt;= 1000<br>0 &lt;= nums1[i], nums2[i] &lt;= 100</p></blockquote><p><strong>题目解析</strong></p><p>LCS属于经典的动态规划问题，同时也是面试场考题，同学们一定要熟悉！</p><ul><li><p>状态转移方程式：<code>dp[i][j]</code> 表示包含 <code>nums1</code> 的第 <code>i</code> 个数字和包含 <code>nums2</code> 的第 <code>j</code> 个数字的最长重复子数组的长度。<code>if nums1[i] == nums[j]: dp[i][j] = dp[i - 1][j - 1] + 1; else: dp[i][j] = 0</code></p></li><li><p>容器规模：<code>i</code> 的范围是 <code>[0, len1]</code> ，<code>j</code> 的范围是 <code>[0, len2]</code></p></li><li><p>base case：由于依赖关系如下因此 basecase 应该是第一行和第一列（红色部分）因此，basecase是 <code>dp[0][j]</code> 和 <code>dp[i][0]</code>，二者均为 0。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154127.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154004.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：从[1, 1]开始从左往右，从上到下填表即可。</p></li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// findLength方法用于找出两个数组nums1和nums2的最长公共子序列的长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// len1和len2分别表示数组nums1和nums2的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length, len2 = nums2.length;<br>        <span class="hljs-comment">// 创建一个二维数组dp，用于存储动态规划过程中的中间结果</span><br>        <span class="hljs-comment">// dp[i][j]表示包含nums1的第i个数字和包含nums2的第j个数字的最长重复子数组的长度</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// ans用于记录最长公共子序列的长度，初始值为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 外层循环遍历nums1数组，从1开始，因为dp[0][j]和dp[i][0]都是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) &#123;<br>            <span class="hljs-comment">// 内层循环遍历nums2数组，同样从1开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) &#123;<br>                <span class="hljs-comment">// 如果nums1[i-1]和nums2[j-1]相等，说明找到了一个公共元素</span><br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-comment">// 更新dp[i][j]为dp[i-1][j-1]+1，即当前元素的最长公共子序列长度为不包含当前元素时的最长公共子序列长度加1</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// 更新ans为ans和dp[i][j]中的最大值，即记录到目前为止找到的最长公共子序列的长度</span><br>                    ans = Math.max(ans, dp[i][j]);<br>                &#125;<br>                <span class="hljs-comment">// 如果nums1[i-1]和nums2[j-1]不相等，则dp[i][j]保持为0，因为公共子序列不能包含不匹配的元素</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最长公共子序列的长度</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a class="markdownIt-Anchor" href="#最长公共子序列"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，<code>“ace”</code> 是 <code>“abcde”</code> 的子序列，但 <code>“aec”</code> 不是 <code>“abcde”</code> 的子序列。</p><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。</p></blockquote><p>示例 3：</p><blockquote><p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= text1.length, text2.length &lt;= 1000<br>text1 和 text2 仅由小写英文字符组成。</p></blockquote><p><strong>题目解析</strong></p><p>同样属于LCS问题中的一类，属于面试常考题，一定要熟悉。</p><ul><li>状态转移方程式：<code>dp[i][j]</code> 表示 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。如果 <code>text1[i - 1]</code> 与 <code>text2[j - 1]</code> 相同，那么找到了一个公共元素，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>;如果 <code>text1[i - 1]</code> 与 <code>text2[j - 1]</code> 不相同，那就看看 <code>text1[0, i - 2]</code> 与 <code>text2[0, j - 1]</code> 的<strong>最长公共子序列</strong>和 <code>text1[0, i - 1]</code> 与 <code>text2[0, j - 2]</code> 的最长公共子序列，取最大的。即：<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code> ;</li><li>容器规模：<code>i</code> 属于<code>[0, text1.length]</code> ，<code>j</code> 属于<code>[0, text2.length]</code></li><li>base case：<code>dp[0][j]</code> 和 <code>dp[i][0]</code> 二者均为0。</li><li>填表顺序：从 <code>[1, 1]</code> 开始从左往右，从上到下填表即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// longestCommonSubsequence方法用于计算两个字符串text1和text2的最长公共子序列的长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// len1和len2分别表示字符串text1和text2的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> text2.length();<br>        <br>        <span class="hljs-comment">// 创建一个二维数组dp，用于存储动态规划过程中的中间结果</span><br>        <span class="hljs-comment">// dp[i][j]表示以text1的前i个字符和text2的前j个字符结尾的最长公共子序列的长度</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 外层循环遍历text1字符串，从1开始，因为dp[0][j]和dp[i][0]都是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1; i++) &#123;<br>            <span class="hljs-comment">// 内层循环遍历text2字符串，同样从1开始</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2; j++) &#123;<br>                <span class="hljs-comment">// 如果text1的第i个字符和text2的第j个字符相同</span><br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-comment">// 更新dp[i][j]为dp[i - 1][j - 1] + 1，即当前字符的最长公共子序列长度为不包含当前字符时的最长公共子序列长度加1</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果当前字符不同，则dp[i][j]取dp[i - 1][j]和dp[i][j - 1]中的较大值</span><br>                    <span class="hljs-comment">// 即选择不包含text1的第i个字符或不包含text2的第j个字符的最长公共子序列长度</span><br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回dp[len1][len2]，即text1和text2的最长公共子序列的长度</span><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个字符串的删除操作"><a class="markdownIt-Anchor" href="#两个字符串的删除操作"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h3><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和  <code>word2</code> <strong>相同</strong> 所需的 <strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p>示例 1：</p><blockquote><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat”变为 “ea”</p></blockquote><p>示例  2:</p><blockquote><p>输入：word1 = “leetcode”, word2 = “etco”<br>输出：4</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= word1.length, word2.length &lt;= 500<br>word1 和 word2 只包含小写英文字母</p></blockquote><p><strong>题目解析</strong></p><ul><li>状态转移方程式：<code>dp[i][j]</code> 考虑 <code>word1</code> 的前 <code>i</code> 个字符和 <code>word2</code> 的前 <code>j</code> 个字符转为相同的最小步数。如果 <code>word1[i]==word2[j]</code> 那么说明这一位是不需要删除的，此时 <code>dp[i][j]=dp[i-1][j-1]</code>。否则，要么删除 <code>word1</code> 的第 <code>i</code> 个字符，要么删除 <code>word2</code> 的第 <code>j</code> 个字符，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1</code></li><li>容器规模：<code>i</code> 属于 <code>[0,len1]</code>，<code>j</code> 属于 <code>[0,len2]</code></li><li>base case：依赖关系与“最长公共子序列”一致，因此basecase是 <code>dp[0][j]</code> 和 <code>dp[i][0]</code>，其中<code>dp[0][j] = j</code>, <code>dp[i][0] = i</code></li><li>填表顺序：从 <code>[1, 1]</code> 开始从左往右，从上到下填表即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// minDistance方法用于计算将字符串word1转换为字符串word2所需的最少操作次数</span><br>    <span class="hljs-comment">// 操作包括插入、删除和替换字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// len1和len2分别表示字符串word1和word2的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> word1.length(), len2 = word2.length();<br>        <br>        <span class="hljs-comment">// 创建一个二维数组dp，用于存储动态规划过程中的中间结果</span><br>        <span class="hljs-comment">// dp[i][j]表示将word1的前i个字符转换为word2的前j个字符所需的最少操作次数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 初始化dp数组的第一列，表示word1为空字符串，转换为word2的任意前缀所需的操作数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <br>        <span class="hljs-comment">// 初始化dp数组的第一行，表示word2为空字符串，将word1的任意前缀转换为空所需的操作数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) dp[i][<span class="hljs-number">0</span>] = i;<br><br>        <span class="hljs-comment">// 外层循环遍历word1字符串，从1开始，因为dp[i][0]已经初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) &#123;<br>            <span class="hljs-comment">// 内层循环遍历word2字符串，从1开始，因为dp[0][j]已经初始化</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) &#123;<br>                <span class="hljs-comment">// 如果word1的第i个字符和word2的第j个字符相同，则不需要任何操作</span><br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果字符不同，则考虑两种情况：</span><br>                    <span class="hljs-comment">// 1. 删除word1的第i个字符，此时操作数为dp[i - 1][j] + 1</span><br>                    <span class="hljs-comment">// 2. 删除word2的第j个字符，此时操作数为dp[i][j - 1] + 1</span><br>                    <span class="hljs-comment">// 取两种情况中的最小值，然后加1，得到dp[i][j]</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回dp[len1][len2]，即word1转换为word2所需的最少操作次数</span><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编辑距离"><a class="markdownIt-Anchor" href="#编辑距离"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的<strong>最少操作数</strong>  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例 1：</p><blockquote><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></blockquote><p>示例 2：</p><blockquote><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p></blockquote><p>提示：</p><blockquote><p>0 &lt;= word1.length, word2.length &lt;= 500<br>word1 和 word2 由小写英文字母组成</p></blockquote><p><strong>题目解析</strong></p><ul><li>状态转移方程式：<code>dp[i][j]</code> 考虑 <code>word1</code> 的前 <code>i</code> 个字符和 <code>word2</code> 的前 <code>j</code> 个字符转为相同的最小步数。如果 <code>word1[i]==word2[j]</code> 那么说明这一位是不需要删除的，此时 <code>dp[i][j]=dp[i-1][j-1]</code>。否则，要么删除 <code>word1</code> 的第 <code>i</code> 个字符，此时 <code>dp[i][j] = dp[i - 1][j] + 1</code>；要么插入一个字符在 <code>word1</code> 后面，与 <code>word2</code> 匹配，此时 <code>dp[i][j] = dp[i][j - 1] + 1</code>; 要么将 <code>word1</code> 的第 <code>i</code> 个字符替换成与 <code>word2</code> 的第 <code>j</code> 个字符一致，此时 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>，在三种操作中选取最小的即可。</li><li>容器规模：<code>i</code> 属于 <code>[0,len1]</code>，<code>j</code> 属于 <code>[0,len2]</code></li><li>base case：依赖关系与“最长公共子序列”一致，因此basecase是 <code>dp[0][j]</code> 和 <code>dp[i][0]</code>，其中 <code>dp[0][j] = j, dp[i][0] = i</code></li><li>填表顺序：从 <code>[1, 1]</code> 开始从左往右，从上到下填表即可。</li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// minDistance方法用于计算将字符串word1转换为字符串word2所需的最少操作次数</span><br>    <span class="hljs-comment">// 操作包括插入、删除和替换字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// len1和len2分别获取字符串word1和word2的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> word1.length(), len2 = word2.length();<br>        <br>        <span class="hljs-comment">// 创建一个二维数组dp，用于存储动态规划过程中的中间结果</span><br>        <span class="hljs-comment">// dp[i][j]表示word1的前i个字符转换为word2的前j个字符所需的最少操作数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 初始化dp数组的第一行，表示word1为空字符串时，转换为word2的任意前缀所需的操作数</span><br>        <span class="hljs-comment">// 即word2的前j个字符需要插入j次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <br>        <span class="hljs-comment">// 初始化dp数组的第一列，表示word2为空字符串时，将word1的任意前缀删除所需的操作数</span><br>        <span class="hljs-comment">// 即word1的前i个字符需要删除i次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) dp[i][<span class="hljs-number">0</span>] = i;<br><br>        <span class="hljs-comment">// 外层循环遍历word1字符串，从1开始，因为dp[i][0]已经初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= len1 ; i++) &#123;<br>            <span class="hljs-comment">// 内层循环遍历word2字符串，从1开始，因为dp[0][j]已经初始化</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; j &lt;= len2 ; j++) &#123;<br>                <span class="hljs-comment">// 如果word1的第i个字符和word2的第j个字符相同，则不需要任何操作</span><br>                <span class="hljs-comment">// dp[i][j]等于dp[i - 1][j - 1]，即word1的前i-1个字符和word2的前j-1个字符的最少操作数</span><br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果字符不同，则考虑三种情况：</span><br>                    <span class="hljs-comment">// 1. 删除word1的第i个字符，此时操作数为dp[i - 1][j] + 1</span><br>                    <span class="hljs-comment">// 2. 在word2的第j个字符前插入一个字符，此时操作数为dp[i][j - 1] + 1</span><br>                    <span class="hljs-comment">// 3. 替换word1的第i个字符为word2的第j个字符，此时操作数为dp[i - 1][j - 1] + 1</span><br>                    <span class="hljs-comment">// 取三种情况中的最小值，然后加1，得到dp[i][j]</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, Math.min(dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回dp[len1][len2]，即word1转换为word2所需的最少操作数</span><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回文子串"><a class="markdownIt-Anchor" href="#回文子串"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">回文子串</a></h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><blockquote><p>输入：s = “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= s.length &lt;= 1000<br>s 由小写英文字母组成</p></blockquote><p><strong>题目解析</strong></p><p>所谓的区间 dp 就是我们定义的 dp 状态是一个区间，然后通过区间的收缩进行状态的转移。</p><ul><li><p>状态转移方程式：<code>dp[i][j]</code> 表示区间 <code>[i,j]</code> 内的子串是否是回文串，这个子串是否是回文串取决于区间端点 <code>s[i]</code> 和 <code>s[j]</code> 是否相等，且 <code>[i + 1, j - 1]</code> 是否为回文串。即 <code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p></li><li><p>容器规模：<code>i</code> 和 <code>j</code> 的范围均为 <code>[0,length - 1]</code></p></li><li><p>base case：<code>i == j</code> 和 <code>i + 1==j</code> 的时候。依赖关系如下任何区间 <code>(i, j)</code> 最终都会依赖值对角线的值上（蓝色和黄色的格子），因此 <code>i==j</code> 和 <code>i+1==j</code> 是basecase。当 <code>i==j</code> 的时候，<code>dp[i][j]</code> 表示的是只有一个字符，<code>dp[i][j]=true</code>；当 <code>i + 1==j</code> 的时候，<code>dp[i][j]</code> 表示的是两个连续的字符，因此 <code>dp[i][j]</code> 是 <code>true</code> 或者 <code>false</code> 取决于 <code>s[i]==s[j]</code>。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182154396.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：先遍历 <code>j</code> ，再遍历 <code>i</code>，<code>i</code> 逆序遍历。（这样才可以保证我们填表的时候依赖的值已经填好了）</p></li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// countSubstrings方法用于统计一个字符串s中所有回文子串的数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 获取字符串s的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 初始化结果res为0，用于计数回文子串的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 创建一个二维布尔数组dp，用于存储动态规划过程中的中间结果</span><br>        <span class="hljs-comment">// dp[i][j]表示字符串s从索引i到j的子串是否为回文</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <br>        <span class="hljs-comment">// 外层循环遍历字符串s的每个字符，j表示子串的结束索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-comment">// 内层循环从j向前遍历，i表示子串的开始索引</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">// 如果开始索引和结束索引相同，即子串长度为1，那么一定是回文</span><br>                <span class="hljs-keyword">if</span> (i == j) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 如果子串长度为2，那么只需要检查两个字符是否相同</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i == <span class="hljs-number">1</span>)  dp[i][j] = (s.charAt(i) == s.charAt(j));<br>                <span class="hljs-comment">// 如果子串长度大于2，那么需要检查去掉首尾字符后子串是否为回文，</span><br>                <span class="hljs-comment">// 并且首尾字符相同</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));<br>                <span class="hljs-comment">// 如果当前子串是回文，那么结果res加1</span><br>                <span class="hljs-keyword">if</span> (dp[i][j]) res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回回文子串的总数</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文子序列"><a class="markdownIt-Anchor" href="#最长回文子序列"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列</a></h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><blockquote><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= s.length &lt;= 1000<br>s 仅由小写英文字母组成</p></blockquote><p><strong>题目解析</strong></p><ul><li><p>状态转移方程式：<code>dp[i][j]</code> 表示区间 <code>[i,j]</code> 内的回文子序列的长度，如果区间端点 <code>s[i]</code> 和 <code>s[j]</code> 相等，则说明这两个端点属于回文子序列中的一部分，即 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code>；否则要么包含 <code>s[i]</code>，要么包含 <code>s[j]</code>，取最大即可，也就是 <code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></p></li><li><p>容器规模：<code>i</code> 和 <code>j</code> 的范围均为 <code>[0,length - 1]</code></p></li><li><p>base case：<code>i == j</code> 和 <code>i + 1==j</code> 的时候。依赖关系如下任何区间 <code>(i, j)</code> 最终都会依赖值对角线的值上（蓝色和黄色的格子），因此 <code>i==j</code> 和 <code>i+1==j</code> 是basecase。当 <code>i==j</code> 的时候，<code>dp[i][j]</code> 表示的是只有一个字符，<code>dp[i][j]=1</code>；当 <code>i + 1==j</code> 的时候，<code>dp[i][j]</code> 表示的是两个连续的字符，因此 <code>dp[i][j]</code> 是取决于 <code>s[i]==s[j]</code>，相等的时候是 <code>2</code>，不等则为 <code>1</code>。</p><p><img src="https://raw.githubusercontent.com/fulequn/oss_img/master/img241/202405182155017.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>填表顺序：先遍历 <code>j</code>，再遍历 <code>i</code>，<code>i</code> 逆序遍历。（这样才可以保证我们填表的时候依赖的值已经填好了）</p></li></ul><p><strong>代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <br>        <span class="hljs-comment">// dp[i][j]表示字符串s从索引i到j的子串的最长回文子序列长度</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <br>        <span class="hljs-comment">// 使用两层循环遍历字符串s，外层循环固定子串的结束索引j</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; n ; j++) &#123;<br>            <span class="hljs-comment">// 内层循环从j向开始遍历，固定子串的开始索引i</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j ; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>                <span class="hljs-comment">// 如果子串只有一个字符，则最长回文子序列长度为1</span><br>                <span class="hljs-keyword">if</span> (i == j) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果子串长度为2，且两个字符相同，则最长回文子序列长度为2</span><br>                <span class="hljs-comment">// 如果两个字符不同，则最长回文子序列长度为1</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j) dp[i][j] = s.charAt(i) == s.charAt(j) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果子串两端的字符相同，则最长回文子序列长度为去掉两端字符后的最长回文子序列长度加2</span><br>                    <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">// 如果子串两端的字符不同，则最长回文子序列长度为不包含当前两端字符中任一端的最长回文子序列长度的最大值</span><br>                    <span class="hljs-keyword">else</span> dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回dp[0][n - 1]，即整个字符串s的最长回文子序列的长度</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a> <span>></span> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a></div></div><div class="license-box my-3"><div class="license-title"><div>算法训练3.2.1 基础DP</div><div>https://fulequn.github.io/2024/05/Article202405181/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年5月18日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/05/Article202405221/" title="算法训练3.2.2 背包模型"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法训练3.2.2 背包模型</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/05/Article202405121/" title="算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第二部分"><span class="hidden-mobile">算法训练3.1 单调栈自顶向下的动态规划（记忆化搜索）第二部分</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>