<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Fulequn"><meta name="keywords" content=""><meta name="description" content="计算机基础  题目 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一 “趟”。下列排序中，不可能是快速排序第二趟结果的是（）【2019 年全国试题 10（2 分）】 A. 5, 2, 16, 12, 28, 60, 32, 72 B. 2, 16, 5, 28, 12, 60, 32, 72 C. 2, 12, 16, 5, 28, 32, 72, 60 D. 5, 2, 12, 28"><meta property="og:type" content="article"><meta property="og:title" content="2024.5.1 计算机基础（快速排序）+算法（最小生成树）"><meta property="og:url" content="https://fulequn.github.io/2024/05/Article202405011/index.html"><meta property="og:site_name" content="FuLeQun&#39;s Blog"><meta property="og:description" content="计算机基础  题目 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一 “趟”。下列排序中，不可能是快速排序第二趟结果的是（）【2019 年全国试题 10（2 分）】 A. 5, 2, 16, 12, 28, 60, 32, 72 B. 2, 16, 5, 28, 12, 60, 32, 72 C. 2, 12, 16, 5, 28, 32, 72, 60 D. 5, 2, 12, 28"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-05-01T12:45:48.000Z"><meta property="article:modified_time" content="2024-05-30T00:16:56.000Z"><meta property="article:author" content="Fulequn"><meta name="twitter:card" content="summary_large_image"><title>2024.5.1 计算机基础（快速排序）+算法（最小生成树） - FuLeQun&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"fulequn.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null,tajs:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>FuLeQun&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="2024.5.1 计算机基础（快速排序）+算法（最小生成树）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-05-01 20:45" pubdate>2024年5月1日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>17 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">2024.5.1 计算机基础（快速排序）+算法（最小生成树）</h1><div class="markdown-body"><h1 id="计算机基础"><a class="markdownIt-Anchor" href="#计算机基础"></a> 计算机基础</h1><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一 “趟”。下列排序中，不可能是快速排序第二趟结果的是（）【2019 年全国试题 10（2 分）】</p><p>A. 5, 2, 16, 12, 28, 60, 32, 72</p><p>B. 2, 16, 5, 28, 12, 60, 32, 72</p><p>C. 2, 12, 16, 5, 28, 32, 72, 60</p><p>D. 5, 2, 12, 28, 16, 32, 72, 60</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>答案：D，分析如下。</p><p>每经过一趟快排，轴点元素都必然就位。也就是说，一趟下来至少有 1 个元素在其最终位置。所以考察各个选项，看有几个元素就位即可。</p><p>最终排序位置是：<strong>2, 5, 12, 16, 28, 32, 60, 72</strong>，而选项中正确的位置有：</p><p>A. 5, 2, 16, 12, <strong>28</strong>, 60, 32, <strong>72</strong></p><p>B. <strong>2</strong>, 16, 5, 28, 12, 60, 32, <strong>72</strong></p><p>C. <strong>2</strong>, 12, 16, 5, <strong>28</strong>, <strong>32</strong>, 72, 60</p><p>D. 5, 2, <strong>12</strong>, 28, 16, <strong>32</strong>, 72, 60</p><ul><li>第一趟排序，确定一个元素位置</li><li>第二趟排序，又确定<strong>一个或两个</strong>元素位置<ul><li>当第一趟元素确认的位置为最左或最右时，第二趟排序<strong>只能确认一个</strong>位置（A，B 选项情况）</li><li>当第一趟元素确认位置不是最左或最右时，第二趟<strong>能确认 2 个</strong>位置（C 选项情况）</li></ul></li></ul><p>所以，两趟排序共确认 2 或 3 个元素位置。</p><h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36553623/article/details/78524754">题目链接</a></p><h2 id="垃圾佬抓宠物"><a class="markdownIt-Anchor" href="#垃圾佬抓宠物"></a> 垃圾佬抓宠物</h2><p>不过，垃圾佬发现，这个网游的抓宠物系统是这样设定的：</p><p>抓特定的某种宠物需要花费特定的魔法豆。</p><p>另外，还可以通过一种宠物的呼唤能力来抓取另一种宠物，当然，要让宠物发挥它的呼唤能力需要两个条件：</p><p>第一，它要是你的宠物……人家还野生呢总不会听你的话陷害好友吧。</p><p>第二，你需要喂给你的宠物一定的魔法豆，它才有力气施展它的能力。</p><p>当另一只宠物被呼唤过来之后，你不费什么力气就可以把它抓住，也就不必再向系统付额外的魔法豆了。</p><p>注意，一种宠物能呼唤另一种宠物是因为他们心灵相通，所以如果A宠物能呼唤B宠物，那么B宠物也一定能呼唤A宠物。</p><p>而且，垃圾佬仔细研究之后发现，可能是OWO的程序员懒得再设置数据，A 宠物呼唤B宠物需要的魔法豆和B宠物呼唤A宠物需要的魔法豆是相等的。</p><p>垃圾佬的目标，当然是要算出最少要花费多少魔法豆啦~</p><p>垃圾佬拿出纸笔，算啊算啊算啊算，就在垃圾佬算出来的一刹那，静静温柔的对垃圾佬说：“Darling，你会不会觉得我很败家啊……其实我也知道我不应该用你的钱来冲魔法豆的”</p><p>垃圾佬心中一喜，抬头看着静静，静静说：“要不你不用抓齐，少抓一只吧。”</p><p><strong>Input</strong></p><p>第一行一个数字n，代表网游里一共有n 种宠物。</p><p>第二行有n 个数字，用空格隔开，依次说明直接抓取第1，2，3，4……n 种宠物需要多</p><p>少魔法豆</p><p>第三行一个C，表示游戏一共设定了C 对宠物心灵相通，可以互相呼唤。</p><p>接下来C 行，每行都有三个数字a，b 和w。代表第a 种和第b 种宠物可以互相呼唤，</p><p>呼唤前需要给a 宠物或b 宠物喂w 魔法豆。</p><p>n≤250，n∈N+</p><p>0&lt;=c&lt;=n*(n-1)/2</p><p>所有数字（含结果）&lt;2^31</p><p><strong>Output</strong></p><p>只有一行，满足MM 需求最少要花费多少魔法豆</p><p><strong>样例1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">Input <br>3<br>10<span class="hljs-number"> 10 </span>10<br>3<br>1<span class="hljs-number"> 2 </span>7<br>1<span class="hljs-number"> 3 </span>1<br>2<span class="hljs-number"> 3 </span>3<br><br>Output<br>11<br><br>样例说明：<br>先抓第一只，然后用第一只呼唤第三只。<br></code></pre></td></tr></table></figure><p>仔细一看，是加一个源点的最小生成树。对于每一个删的节点进行枚举，因为n很小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个结构体用于存储边的信息：起点、终点和边的权重</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cost; <span class="hljs-comment">// cost存路程</span><br>&#125;;<br><br><span class="hljs-comment">// 用于查找节点x所在的集合的代表元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">fi</span>(fa[x]);<br>&#125;<br><br><span class="hljs-comment">// 用于比较两个节点结构体的大小，按照cost进行排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.cost &lt; b.cost; <span class="hljs-comment">// 找路程小的</span><br>&#125;<br><br><span class="hljs-comment">// 合并两个节点x和y所在的集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unio</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">fi</span>(x), p2 = <span class="hljs-built_in">fi</span>(y);<br>    <span class="hljs-keyword">if</span> (p1 != p2) fa[p1] = p2;<br>&#125;<br><br><span class="hljs-comment">// 主要的解法函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-type">int</span> ans = ~<span class="hljs-number">0U</span> &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// ans初始化为无穷大</span><br>        <span class="hljs-type">int</span> v[maxn], fa[maxn]; <span class="hljs-comment">// v数组和fa数组</span><br>        node Q[maxn]; <span class="hljs-comment">// 存储边的数组</span><br><br>        <span class="hljs-comment">// 读取顶点的数值和边的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><br>        <span class="hljs-comment">// 读取每条边的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;Q[i].x, &amp;Q[i].y, &amp;Q[i].cost);<br><br>        <span class="hljs-comment">// 将顶点的数值作为边加入到边的数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            Q[i + m].x = <span class="hljs-number">0</span>;<br>            Q[i + m].y = i;<br>            Q[i + m].cost = v[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 对边进行排序，优先选择权重小的边</span><br>        <span class="hljs-built_in">sort</span>(Q + <span class="hljs-number">1</span>, Q + <span class="hljs-number">1</span> + m, cmp);<br><br>        <span class="hljs-comment">// 尝试每一种顶点作为起点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化总权重为0</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fa[i] = i; <span class="hljs-comment">// 初始化每个节点所在集合的代表元素为自己</span><br><br>            <span class="hljs-comment">// 遍历所有边，如果边的起点或终点是j，则跳过</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>                <span class="hljs-keyword">if</span> (Q[i].x == j || Q[i].y == j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fi</span>(Q[i].x) == <span class="hljs-built_in">fi</span>(Q[i].y)) <span class="hljs-comment">// 如果两个节点已经在同一个集合中，则跳过</span><br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">unio</span>(Q[i].x, Q[i].y); <span class="hljs-comment">// 合并两个节点所在的集合</span><br>                sum += Q[i].cost; <span class="hljs-comment">// 累加权重</span><br>            &#125;<br>            ans = <span class="hljs-built_in">min</span>(ans, sum); <span class="hljs-comment">// 更新最小权重和</span><br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl; <span class="hljs-comment">// 输出最小权重和</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; <span class="hljs-comment">// 测试用例个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cas = <span class="hljs-number">1</span>; cas &lt;= t; cas++) &#123;<br>        <span class="hljs-built_in">solve</span>(); <span class="hljs-comment">// 调用解法函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/mst/#prim-%E7%AE%97%E6%B3%95">最小生成树 - OI Wiki</a></p><p>是的，这段代码采用的最小生成树算法是基于 Prim 算法的变种。Prim 算法是一种用于寻找图的最小生成树的算法，它通过逐步增加边来构建最小生成树，直到所有需要连接的顶点都被包含在内。在每步中，它都会选择连接树与非树顶点间权重最小的边，将其添加到最小生成树中。<br>以下是代码中体现 Prim 算法的几个关键点：</p><ol><li><strong>初始化</strong>：<code>ans</code> 用于记录最小生成树的总权重，初始设为无穷大。<code>fa</code> 数组用于记录并查集的父节点，初始时每个节点的父节点都是自己，表示每个节点独立。</li><li><strong>排序</strong>：将所有的边按照权重进行排序，这样可以选择最小的边添加到生成树中。</li><li><strong>循环</strong>：对于每个顶点 <code>j</code>，都尝试将其作为最小生成树的一个起点。</li><li><strong>并查集</strong>：使用 <code>fi</code> 函数（查找代表元素）和 <code>unio</code> 函数（合并两个节点所在的集合）来维护并查集，以快速判断两个节点是否已经在同一棵树中。</li><li><strong>权重累加</strong>：对于排序后的每条边，如果边的两个顶点不在同一棵树中，则将这条边添加到最小生成树中，并通过 <code>sum += Q[i].cost</code> 累加其权重。</li><li><strong>最小权重更新</strong>：在每次循环结束后，使用 <code>ans = min(ans, sum)</code> 来更新最小生成树的总权重。</li></ol><p>代码通过重复这个过程来找到所有顶点的最小生成树，并输出最小的总权重。这种处理方式是 Prim 算法的典型实现。</p></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>2024.5.1 计算机基础（快速排序）+算法（最小生成树）</div><div>https://fulequn.github.io/2024/05/Article202405011/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fulequn</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年5月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/05/Article202405021/" title="常见的查找算法与排序算法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">常见的查找算法与排序算法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/04/Article202404301/" title="如何实现第三方授权登录？"><span class="hidden-mobile">如何实现第三方授权登录？</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>